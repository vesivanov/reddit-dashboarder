<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Reddit Three-Pane Dashboard</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
  <script src="https://cdn.tailwindcss.com"></script>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <style>
    body { font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial; }
  </style>
</head>
<body class="bg-zinc-50 min-h-screen text-zinc-900">
  <div id="root"></div>
  <script>
    const { useEffect, useMemo, useState, useCallback } = React;
    const { createRoot } = ReactDOM;
    const h = React.createElement;

    const DEFAULT_API_URL = "/api/reddit";
    const DEFAULT_SUBS = [];

    function App() {
      const [subs, setSubs] = useState(() => {
        try {
          // Try primary storage first
          let saved = localStorage.getItem('dashboard_subs');
          if (saved) return JSON.parse(saved);
          
          // Fallback to backup storage
          saved = localStorage.getItem('dashboard_subs_backup');
          if (saved) {
            const parsed = JSON.parse(saved);
            // Restore to primary storage
            localStorage.setItem('dashboard_subs', saved);
            return parsed;
          }
        } catch (error) {
          console.warn('Unable to parse saved subs', error);
        }
        return DEFAULT_SUBS;
      });
      const [subsInput, setSubsInput] = useState(() => {
        try {
          const saved = localStorage.getItem('dashboard_subs');
          if (saved) {
            const subs = JSON.parse(saved);
            return subs.join(', ');
          }
        } catch (error) {
          console.warn('Unable to parse saved subs', error);
        }
        return '';
      });
      const [mode, setMode] = useState('new');
      const [time, setTime] = useState('day');
      const [days, setDays] = useState(1);
      const [limit, setLimit] = useState(100);
      const [maxPages, setMaxPages] = useState(() => {
        try {
          const saved = localStorage.getItem('dashboard_max_pages');
          if (saved) return Math.max(1, Math.min(500, Number(saved) || 5));
        } catch (error) {}
        return 100;
      });
      const [loading, setLoading] = useState(false);
      const [error, setError] = useState('');
      const [needsAuth, setNeedsAuth] = useState(false);
      const [data, setData] = useState([]);
      const [selectedSub, setSelectedSub] = useState('ALL');
      const [selectedPost, setSelectedPost] = useState(null);
      const [fetchedAt, setFetchedAt] = useState(null);
      const [keyword, setKeyword] = useState('');
      const [fetchMethod, setFetchMethod] = useState('server'); // Track which method was used
      const [authenticated, setAuthenticated] = useState(false);
      const [authChecking, setAuthChecking] = useState(true);
      const [subsExpanded, setSubsExpanded] = useState(false);
      const [keywordExpanded, setKeywordExpanded] = useState(false);
      const [insightsExpanded, setInsightsExpanded] = useState(false);
      const [insightRange, setInsightRange] = useState(() => {
        try {
          return localStorage.getItem('dashboard_insight_range') || 'day';
        } catch {
          return 'day';
        }
      });
      const [enabledInsights, setEnabledInsights] = useState(() => {
        try {
          const stored = localStorage.getItem('dashboard_insight_toggles');
          if (stored) {
            const parsed = JSON.parse(stored);
            return {
              topScoreDelta: parsed.topScoreDelta !== false,
              subredditActivity: parsed.subredditActivity !== false,
              keywordFrequency: parsed.keywordFrequency !== false,
            };
          }
        } catch (error) {
          console.warn('Unable to read insight toggles', error);
        }
        return {
          topScoreDelta: true,
          subredditActivity: true,
          keywordFrequency: true,
        };
      });

      useEffect(() => {
        try {
          // Save to both primary and backup storage
          const subsJson = JSON.stringify(subs);
          localStorage.setItem('dashboard_subs', subsJson);
          localStorage.setItem('dashboard_subs_backup', subsJson);
          
          // Also save a timestamp for debugging
          localStorage.setItem('dashboard_subs_last_saved', new Date().toISOString());
        } catch (storageError) {
          console.warn('Unable to persist subs', storageError);
        }
      }, [subs]);

      useEffect(() => {
        // Sync subsInput when subs changes (e.g., from localStorage)
        setSubsInput(subs.join(', '));
      }, [subs]);

      useEffect(() => {
        try { localStorage.setItem('dashboard_max_pages', String(maxPages)); } catch {}
      }, [maxPages]);

      useEffect(() => {
        try { localStorage.setItem('dashboard_insight_range', insightRange); } catch {}
      }, [insightRange]);

      useEffect(() => {
        try { localStorage.setItem('dashboard_insight_toggles', JSON.stringify(enabledInsights)); } catch {}
      }, [enabledInsights]);

      useEffect(() => {
        let cancelled = false;

        async function checkAuth() {
          setAuthChecking(true);
          try {
            const response = await fetch('/api/auth/status', { cache: 'no-store' });
            if (!response.ok) throw new Error('Failed to check auth status');
            const payload = await response.json();
            if (!cancelled) {
              setAuthenticated(Boolean(payload.authenticated));
            }
          } catch (statusError) {
            if (!cancelled) {
              setAuthenticated(false);
            }
          } finally {
            if (!cancelled) {
              setAuthChecking(false);
            }
          }
        }

        checkAuth();

        return () => {
          cancelled = true;
        };
      }, []);

      const allPosts = useMemo(() => {
        const rows = [];
        for (const group of data) {
          for (const post of group.posts || []) {
            rows.push(post);
          }
        }
        rows.sort((a, b) => (b.created_utc || 0) - (a.created_utc || 0));
        return rows;
      }, [data]);

      const filteredBySub = useMemo(() => {
        if (selectedSub === 'ALL') return allPosts;
        const selected = selectedSub.toLowerCase();
        return allPosts.filter(post => post.subreddit?.toLowerCase() === selected);
      }, [allPosts, selectedSub]);

      const visiblePosts = useMemo(() => {
        const q = keyword.trim().toLowerCase();
        if (!q) return filteredBySub;
        return filteredBySub.filter(post => {
          const title = post.title ? post.title.toLowerCase() : '';
          const selftext = post.selftext ? post.selftext.toLowerCase() : '';
          return title.includes(q) || selftext.includes(q);
        });
      }, [filteredBySub, keyword]);

      const subMetaMap = useMemo(() => {
        const map = new Map();
        for (const group of data) {
          map.set(group.subreddit, group.meta || null);
        }
        return map;
      }, [data]);
      const subPartialMap = useMemo(() => {
        const map = new Map();
        for (const group of data) {
          map.set(group.subreddit, Boolean(group.partial));
        }
        return map;
      }, [data]);

      const insightTimeframe = useMemo(() => buildInsightTimeframe(insightRange), [insightRange]);
      const insightFilters = useMemo(() => ({
        selectedSubreddits: selectedSub === 'ALL' ? undefined : [selectedSub],
        keywordQuery: keyword.trim(),
        timeframe: insightTimeframe,
      }), [selectedSub, keyword, insightTimeframe]);
      const dashboardInsights = useMemo(() => computeDashboardInsights(allPosts, insightFilters), [allPosts, insightFilters]);
      const insightTimeframeLabel = useMemo(() => formatInsightTimeframe(insightTimeframe), [insightTimeframe]);

      const handleToggleInsight = useCallback((key, enabled) => {
        setEnabledInsights(current => ({ ...current, [key]: enabled }));
      }, []);

      async function refresh() {
        if (!subs.length) {
          setNeedsAuth(false);
          setError('Please add at least one subreddit.');
          setData([]);
          setFetchedAt(null);
          return;
        }

        setLoading(true);
        setError('');
        setNeedsAuth(false);
        setSelectedPost(null);
        const controller = new AbortController();
        const timeoutMs = Math.min(45000, 5000 + subs.length * 3000);
        const timeoutId = setTimeout(() => controller.abort(), timeoutMs);

        try {
          const params = new URLSearchParams({
            subs: subs.join(','),
            mode,
            time,
            days: String(days),
            // If many subreddits are requested, cap per-page limit to reduce load
            limit: String(subs.length > 6 ? Math.min(50, limit) : limit)
          });
          if (mode === 'new') {
            // Lower max pages by default for many subs to avoid timeouts
            const effMaxPages = subs.length > 6 ? Math.min(10, maxPages) : maxPages;
            params.set('max_pages', String(effMaxPages));
          }

          // Use server API directly (client-side has CORS issues)
          setFetchMethod('server');
          const qs = new URLSearchParams(params);
          const response = await fetch(`${DEFAULT_API_URL}?${qs.toString()}`, { cache: 'no-store', signal: controller.signal });

          if (response.status === 401) {
            setNeedsAuth(true);
            setAuthenticated(false);
            setAuthChecking(false);
            setError('Sign in with Reddit to fetch your dashboard.');
            setData([]);
            setFetchedAt(null);
            return;
          }

          if (!response.ok) throw new Error(`HTTP ${response.status}`);

          const rateLimitedHeader = response.headers.get('X-Rate-Limited') === '1';
          const payload = await response.json();
          if (rateLimitedHeader || payload.rate_limited) {
            setError('Reddit is rate limiting right now. Some subreddits returned no data. Try fewer subreddits, lower max pages, or wait a minute.');
          }
          const results = Array.isArray(payload.results) ? payload.results : [];
          const perSub = subs.map(sub => {
            const match = results.find(r => (r.subreddit || '').toLowerCase() === sub.toLowerCase());
            if (match) return {
              subreddit: match.subreddit,
              meta: match.meta || null,
              posts: match.posts || [],
              partial: Boolean(match.partial),
              error: match.error || null,
            };
            return { subreddit: sub, posts: [], meta: null, partial: false, error: null };
          });
          setNeedsAuth(false);
          setAuthenticated(true);
          setAuthChecking(false);
          setData(perSub);
          setFetchedAt(Date.now());
        } catch (fetchError) {
          setNeedsAuth(false);
          if (fetchError && fetchError.name === 'AbortError') {
            const seconds = Math.round(timeoutMs / 1000);
            setError(`Request timed out (${seconds}s). Reddit may be rate limiting. Try fewer subreddits or try again.`);
          } else if (fetchError && typeof fetchError.message === 'string' && fetchError.message.toLowerCase().includes('rate')) {
            setError('Reddit is rate limiting right now. Please wait a minute and try again.');
          } else {
            setError(fetchError.message || 'Failed to fetch');
          }
          setData([]);
          setFetchedAt(null);
        } finally {
          clearTimeout(timeoutId);
          setLoading(false);
        }
      }

      // Auto-refresh disabled by request: no background interval, no initial fetch
      // useEffect(() => {
      //   const id = setInterval(() => {
      //     refresh();
      //   }, 60 * 60 * 1000);
      //   return () => clearInterval(id);
      //   // eslint-disable-next-line react-hooks/exhaustive-deps
      // }, [subs, mode, time, days, limit, maxPages, workerUrl]);

      // useEffect(() => {
      //   refresh();
      //   // eslint-disable-next-line react-hooks/exhaustive-deps
      // }, []);

      return h('div', { className: 'max-w-7xl mx-auto p-4' },
        h('header', { className: 'flex flex-col md:flex-row md:items-end md:justify-between gap-3 mb-4' },
          h('div', null,
            h('h1', { className: 'text-2xl font-extrabold' }, 'Reddit Dashboarder'),
            h('p', { className: 'text-zinc-600 text-sm' }, 'Three-pane â€¢ Keyword filter â€¢ Day / 3 Days / Week â€¢ Full post body + subreddit stats')
          ),
          h('div', { className: 'flex flex-wrap items-center gap-2' },
            h('select', {
              className: 'border rounded-lg px-3 py-2',
              value: mode,
              onChange: event => setMode(event.target.value)
            },
              h('option', { value: 'new' }, 'new'),
              h('option', { value: 'top' }, 'top')
            ),
            h('select', {
              className: 'border rounded-lg px-3 py-2',
              value: time,
              onChange: event => setTime(event.target.value),
              disabled: mode !== 'top'
            },
              h('option', { value: 'hour' }, 'hour'),
              h('option', { value: 'day' }, 'day'),
              h('option', { value: 'week' }, 'week'),
              h('option', { value: 'month' }, 'month')
            ),
            h('select', {
              className: 'border rounded-lg px-3 py-2',
              value: days,
              onChange: event => setDays(Number(event.target.value) || 1)
            },
              h('option', { value: 1 }, 'Day'),
              h('option', { value: 3 }, '3 Days'),
              h('option', { value: 7 }, 'Week')
            ),
            h('select', {
              className: 'border rounded-lg px-3 py-2',
              value: maxPages,
              onChange: event => setMaxPages(Math.max(1, Math.min(500, Number(event.target.value) || 100)))
            },
              h('option', { value: 5 }, 'Max pages: 5'),
              h('option', { value: 10 }, 'Max pages: 10'),
              h('option', { value: 20 }, 'Max pages: 20'),
              h('option', { value: 50 }, 'Max pages: 50'),
              h('option', { value: 100 }, 'Max pages: 100'),
              h('option', { value: 200 }, 'Max pages: 200')
            ),
            h('button', {
              onClick: refresh,
              className: 'px-4 py-2 rounded-xl bg-black text-white font-semibold shadow disabled:opacity-50',
              disabled: loading
            }, loading ? 'Fetchingâ€¦' : 'Refresh'),
            authChecking
              ? h('div', {
                  className: 'px-3 py-2 rounded-xl border border-dashed border-zinc-300 bg-zinc-50 text-sm text-zinc-500 flex items-center gap-2'
                },
                  h('div', { className: 'w-3 h-3 border-2 border-zinc-300 border-t-zinc-600 rounded-full animate-spin' }),
                  'Checking authâ€¦'
                )
              : authenticated
                ? h('button', {
                    type: 'button',
                    className: 'px-3 py-2 rounded-xl border border-zinc-200 bg-white text-zinc-800 hover:bg-zinc-50 transition-colors font-semibold shadow-sm',
                    onClick: () => { window.location.href = '/api/auth/logout'; }
                  }, 'Sign out')
                : h('button', {
                    type: 'button',
                    className: 'px-3 py-2 rounded-xl border border-zinc-200 bg-white text-zinc-800 hover:bg-zinc-50 transition-colors font-semibold shadow-sm',
                    onClick: () => { window.location.href = '/api/auth/start'; }
                  }, 'Sign in')
          ),
        ),
        needsAuth ? h('div', { className: 'mb-3 rounded-2xl border border-amber-300 bg-amber-50 text-amber-900 px-4 py-3 space-y-1' },
          h('p', { className: 'font-semibold' }, 'Sign in required'),
          h('p', { className: 'text-sm' }, 'Sign in with Reddit to load personalized data for your dashboard.'),
        ) : null,
          h('div', { className: 'mb-3 space-y-2' },
          h('div', { className: 'bg-white rounded-2xl shadow p-3' },
            h('button', {
              className: 'w-full flex items-center justify-between text-left',
              onClick: () => setSubsExpanded(!subsExpanded)
            },
              h('div', { className: 'flex items-center gap-2' },
                h('span', { className: 'font-medium' }, 'Subreddits'),
                subs.length > 0 && h('span', { className: 'px-2 py-0.5 rounded-full bg-blue-100 text-blue-700 text-xs' }, `${subs.length} added`)
              ),
              h('span', { className: 'text-zinc-400' }, subsExpanded ? 'â–¼' : 'â–¶')
            ),
            subsExpanded && h('div', { className: 'mt-3 pt-3 border-t border-zinc-200' },
              h('textarea', {
                className: 'w-full border rounded-lg px-3 py-2 text-sm',
                rows: 3,
                value: subsInput,
                placeholder: 'Enter subreddit names separated by commas (e.g., programming, r/technology, webdev)',
                onChange: event => setSubsInput(event.target.value),
                onBlur: event => {
                  const list = event.target.value.split(',').map(item => {
                    const trimmed = item.trim();
                    return trimmed.startsWith('r/') ? trimmed.substring(2) : trimmed;
                  }).filter(Boolean);
                  setSubs(list);
                  try {
                    localStorage.setItem('dashboard_subs', JSON.stringify(list));
                    localStorage.setItem('dashboard_subs_backup', JSON.stringify(list));
                  } catch (e) {
                    console.warn('Failed to save subreddits:', e);
                  }
                }
              }),
              h('div', { className: 'flex flex-wrap gap-2 mt-2' },
                h('button', {
                  className: 'px-2 py-1 text-xs rounded-lg bg-blue-100 text-blue-700 hover:bg-blue-200',
                  onClick: () => {
                    const backup = JSON.stringify({ subs, maxPages });
                    navigator.clipboard.writeText(backup);
                    alert('Settings copied to clipboard!');
                  }
                }, 'ðŸ“‹ Export'),
                h('button', {
                  className: 'px-2 py-1 text-xs rounded-lg bg-green-100 text-green-700 hover:bg-green-200',
                  onClick: () => {
                    const input = prompt('Paste your settings backup:');
                    if (input) {
                      try {
                        const parsed = JSON.parse(input);
                        if (parsed.subs) setSubs(parsed.subs);
                        if (parsed.maxPages) setMaxPages(parsed.maxPages);
                        alert('Settings restored!');
                      } catch (e) {
                        alert('Invalid backup format');
                      }
                    }
                  }
                }, 'ðŸ“¥ Import')
              )
            )
          ),
          h('div', { className: 'bg-white rounded-2xl shadow p-3' },
            h('button', {
              className: 'w-full flex items-center justify-between text-left',
              onClick: () => setKeywordExpanded(!keywordExpanded)
            },
              h('div', { className: 'flex items-center gap-2' },
                h('span', { className: 'font-medium' }, 'Search'),
                keyword && h('span', { className: 'px-2 py-0.5 rounded-full bg-green-100 text-green-700 text-xs' }, `"${keyword}"`)
              ),
              h('span', { className: 'text-zinc-400' }, keywordExpanded ? 'â–¼' : 'â–¶')
            ),
            keywordExpanded && h('div', { className: 'mt-3 pt-3 border-t border-zinc-200' },
              h('input', {
                className: 'w-full border rounded-lg px-3 py-2 text-sm',
                value: keyword,
                onChange: event => setKeyword(event.target.value),
                placeholder: 'Type a keyword or phrase to search posts...'
              })
            )
          ),
          h('div', { className: 'bg-white rounded-2xl shadow p-3' },
            h('button', {
              className: 'w-full flex items-center justify-between text-left',
              onClick: () => setInsightsExpanded(!insightsExpanded)
            },
              h('div', { className: 'flex items-center gap-2' },
                h('span', { className: 'font-medium' }, 'Insights'),
                h('span', { className: 'px-2 py-0.5 rounded-full bg-purple-100 text-purple-700 text-xs' }, `${Object.values(enabledInsights).filter(Boolean).length} visible`)
              ),
              h('span', { className: 'text-zinc-400' }, insightsExpanded ? 'â–¼' : 'â–¶')
            ),
            insightsExpanded && h('div', { className: 'mt-3 pt-3 border-t border-zinc-200 space-y-3' },
              h('div', { className: 'space-y-2' },
                [
                  ['topScoreDelta', 'Top score delta'],
                  ['subredditActivity', 'Subreddit activity'],
                  ['keywordFrequency', 'Keyword frequency'],
                ].map(([key, label]) => h('label', { key, className: 'flex items-center gap-2 text-sm' },
                  h('input', {
                    type: 'checkbox',
                    checked: enabledInsights[key],
                    onChange: event => handleToggleInsight(key, event.target.checked)
                  }),
                  h('span', { className: 'text-zinc-700' }, label)
                ))
              ),
              h('label', { className: 'block text-sm space-y-1' },
                h('span', { className: 'text-xs text-zinc-500 uppercase tracking-wide' }, 'Timeframe'),
                h('select', {
                  className: 'w-full border rounded-lg px-3 py-2 text-sm',
                  value: insightRange,
                  onChange: event => setInsightRange(event.target.value)
                },
                  h('option', { value: 'day' }, 'Past 24 hours'),
                  h('option', { value: '3days' }, 'Past 3 days'),
                  h('option', { value: 'week' }, 'Past 7 days'),
                  h('option', { value: 'all' }, 'All available data')
                )
              ),
              h('p', { className: 'text-xs text-zinc-500' }, `Window: ${insightTimeframeLabel}`)
            )
          )
        ),
        h('div', { className: 'text-sm text-zinc-600 mb-2' },
          error
            ? h('span', { className: 'text-red-600' }, `Error: ${error}`)
            : h('span', null, 
                loading 
                  ? 'â³ Fetching from Reddit (this may take 30-60 seconds due to rate limits)...'
                  : `Fetched: ${fetchedAt ? formatDateTime(fetchedAt) : 'â€”'} â€¢ Posts: ${visiblePosts.length} â€¢ Mode: ${mode}${mode === 'top' ? ` (t=${time})` : ''} â€¢ Range: ${days} day(s) â€¢ Method: ${fetchMethod === 'client' ? 'ðŸŒ Client-side' : 'ðŸ–¥ï¸ Server'}`
              )
        ),
        h('div', { className: 'grid grid-cols-1 lg:grid-cols-12 gap-4' },
          h('aside', { className: 'lg:col-span-3 bg-white rounded-2xl shadow p-3' },
            h('div', { className: 'flex items-center justify-between mb-3' },
              h('h2', { className: 'font-semibold' }, 'Subreddits'),
              h('button', {
                className: 'text-xs px-2 py-1 rounded-lg bg-zinc-100 hover:bg-zinc-200',
                onClick: () => setSelectedSub('ALL')
              }, 'All')
            ),
            subs.length === 0 
              ? h('div', { className: 'text-sm text-zinc-500 italic text-center py-8' }, 
                  h('div', { className: 'space-y-2' },
                    h('div', null, 'No subreddits added yet'),
                    h('div', { className: 'text-xs' }, 'Click "Subreddits" above to add some')
                  )
                )
              : h('div', { className: 'space-y-2 max-h-[70vh] overflow-auto' },
                  subs.map(sub => {
                    const meta = subMetaMap.get(sub) || {};
                    const capped = subPartialMap.get(sub);
                    const postCount = allPosts.filter(post => post.subreddit?.toLowerCase() === sub.toLowerCase()).length;
                    return h('div', { key: sub, className: 'border border-zinc-200 rounded-lg p-3 hover:border-zinc-300 transition-colors' },
                      h('button', {
                        onClick: () => setSelectedSub(sub),
                        className: `w-full text-left ${selectedSub === sub ? 'font-semibold' : ''}`
                      },
                        h('div', { className: 'flex items-center justify-between mb-2' },
                          h('span', { className: 'text-sm font-medium' }, `r/${sub}`),
                          h('span', { className: 'text-xs text-zinc-500' }, `${postCount} posts`)
                        ),
                        h('div', { className: 'flex items-center gap-2 text-xs text-zinc-500' },
                          h('span', null, `${formatSubs(meta.subscribers)} subscribers`),
                          meta.active_user_count && h('span', null, `â€¢ ${formatSubs(meta.active_user_count)} active`),
                          capped && h('span', { className: 'px-1.5 py-0.5 rounded bg-orange-100 text-orange-700 border border-orange-200' }, 'capped')
                        )
                      )
                    );
                  })
                ),
            subs.length > 0 && h('p', { className: 'text-[11px] text-zinc-500 mt-3 pt-3 border-t border-zinc-200' }, 'Active â‰ˆ users online/active (15m window if provided by Reddit). Weekly contributors aren\'t available via public endpoints.')
          ),
          h('main', { className: 'lg:col-span-5 bg-white rounded-2xl shadow p-3 max-h-[80vh] overflow-auto' },
            h('h2', { className: 'font-semibold mb-3' }, selectedSub === 'ALL' ? 'Latest from all' : `Latest in r/${selectedSub}`),
            visiblePosts.length === 0 && h('div', { className: 'text-sm text-zinc-500' }, 
              subs.length === 0 
                ? 'Add some subreddits to get started!'
                : 'No posts. Try Refresh or adjust filters.'
            ),
            h('ul', { className: 'divide-y' },
              visiblePosts.map(post => h('li', { key: post.id },
                h('button', {
                  className: 'w-full text-left py-3 hover:bg-zinc-50',
                  onClick: () => setSelectedPost(post)
                },
                  h('div', { className: 'flex gap-3 items-start px-2' },
                    post.thumbnail && h('img', {
                      src: post.thumbnail,
                      alt: '',
                      className: 'w-14 h-14 object-cover rounded-lg'
                    }),
                    h('div', { className: 'flex-1' },
                      h('div', { className: 'flex items-center gap-2 text-xs text-zinc-500' },
                        h('span', { className: 'tracking-wide uppercase' }, timeAgo(post.created_utc)),
                        h('span', { className: 'px-2 py-0.5 rounded bg-zinc-100 text-zinc-700' }, `r/${post.subreddit}`)
                      ),
                      h('div', { className: 'font-semibold leading-snug mt-1' }, post.title || ''),
                      h('div', { className: 'flex flex-wrap items-center gap-2 mt-1 text-sm' },
                        h('span', { className: 'px-2 py-0.5 rounded bg-green-100 text-green-700 font-semibold' }, `â–² ${post.score} upvotes`),
                        h('span', { className: 'px-2 py-0.5 rounded bg-yellow-100 text-yellow-700 font-semibold' }, `ðŸ’¬ ${post.num_comments} comments`),
                        h('span', { className: 'text-zinc-600' }, `u/${post.author} â€¢ ${post.domain}`)
                      )
                    )
                  )
                ))
              )
            )
          ),
          h('div', { className: 'lg:col-span-4 flex flex-col gap-4 max-h-[80vh]' },
            h(InsightsPanel, {
              insights: dashboardInsights,
              enabledInsights,
              onToggle: handleToggleInsight,
              timeframeLabel: insightTimeframeLabel,
            }),
            h('section', { className: 'bg-white rounded-2xl shadow p-3 flex-1 overflow-auto' },
              h('h2', { className: 'font-semibold mb-2' }, 'Post'),
              !selectedPost
                ? h('div', { className: 'text-sm text-zinc-500' }, 'Select a post to preview.')
                : h('article', null,
                    h('div', { className: 'flex items-center gap-2 text-xs text-zinc-500' },
                      h('span', { className: 'tracking-wide uppercase' }, timeAgo(selectedPost.created_utc)),
                      h('span', { className: 'px-2 py-0.5 rounded bg-zinc-100 text-zinc-700' }, `r/${selectedPost.subreddit}`)
                    ),
                    h('h3', { className: 'text-lg font-bold mt-1 mb-2' }, selectedPost.title || ''),
                    h('div', { className: 'flex flex-wrap items-center gap-2 text-sm mb-3' },
                      h('span', { className: 'px-2 py-0.5 rounded bg-green-100 text-green-700 font-semibold' }, `â–² ${selectedPost.score} upvotes`),
                      h('span', { className: 'px-2 py-0.5 rounded bg-yellow-100 text-yellow-700 font-semibold' }, 'ðŸ’¬ ' + String(selectedPost.num_comments) + ' comments'),
                      h('span', { className: 'text-zinc-600' }, `u/${selectedPost.author} â€¢ ${selectedPost.domain}`)
                    ),
                    renderBody(selectedPost),
                    h('a', {
                      href: selectedPost.url,
                      target: '_blank',
                      rel: 'noreferrer',
                      className: 'inline-block mt-4 px-4 py-2 rounded-xl bg-black text-white font-semibold shadow'
                    }, 'Open on Reddit')
                  )
            )
          )
        )
      );

    }

    const INSIGHT_LABELS = {
      topScoreDelta: 'Risers',
      subredditActivity: 'Active subreddits',
      keywordFrequency: 'Trending keywords',
    };

    const INSIGHT_STOP_WORDS = new Set(['a','an','and','are','as','at','be','but','by','for','from','has','have','in','into','is','it','its','of','on','or','that','the','their','there','to','was','were','will','with','you','your','i','we','they','this','those','these','what','when','where','who','how','why']);

    function buildInsightTimeframe(range) {
      const now = Math.floor(Date.now() / 1000);
      switch (range) {
        case 'day':
          return { start: now - 86400, end: now };
        case '3days':
          return { start: now - 86400 * 3, end: now };
        case 'week':
          return { start: now - 86400 * 7, end: now };
        default:
          return null;
      }
    }

    function formatInsightTimeframe(timeframe) {
      if (!timeframe || (!timeframe.start && !timeframe.end)) {
        return 'All posts';
      }
      const startDate = timeframe.start ? new Date(timeframe.start * 1000) : null;
      const endDate = timeframe.end ? new Date(timeframe.end * 1000) : new Date();
      if (!startDate) {
        return `Before ${endDate.toLocaleString()}`;
      }
      return `${startDate.toLocaleString()} â†’ ${endDate.toLocaleString()}`;
    }

    function normalizePostForInsights(post) {
      const score = typeof post.score === 'number' ? post.score : 0;
      const previous = typeof post.previous_score === 'number'
        ? post.previous_score
        : typeof post.previousScore === 'number'
          ? post.previousScore
          : score;
      const explicitDelta = typeof post.score_delta === 'number'
        ? post.score_delta
        : typeof post.scoreDelta === 'number'
          ? post.scoreDelta
          : null;
      const scoreDelta = explicitDelta !== null ? explicitDelta : score - previous;
      return {
        ...post,
        created_utc: typeof post.created_utc === 'number' ? post.created_utc : 0,
        scoreDelta,
        keywords: extractInsightKeywords(post.title, post.selftext),
      };
    }

    function extractInsightKeywords(title, body) {
      const source = `${title || ''} ${body || ''}`.toLowerCase();
      return source
        .split(/[^a-z0-9']+/)
        .map(token => token.replace(/^'+|'+$/g, ''))
        .filter(token => token.length >= 3 && !INSIGHT_STOP_WORDS.has(token));
    }

    function applyInsightFilters(posts, filters) {
      const selected = (filters.selectedSubreddits || []).map(name => name.replace(/^r\//i, '').toLowerCase());
      const keyword = (filters.keywordQuery || '').toLowerCase();
      const start = filters.timeframe && typeof filters.timeframe.start === 'number' ? filters.timeframe.start : null;
      const end = filters.timeframe && typeof filters.timeframe.end === 'number' ? filters.timeframe.end : null;
      return posts.filter(post => {
        if (selected.length > 0) {
          const sub = (post.subreddit || '').replace(/^r\//i, '').toLowerCase();
          if (!selected.includes(sub)) {
            return false;
          }
        }
        if (start !== null && post.created_utc < start) return false;
        if (end !== null && post.created_utc > end) return false;
        if (keyword) {
          const haystack = `${post.title || ''} ${post.selftext || ''}`.toLowerCase();
          if (!haystack.includes(keyword)) {
            return false;
          }
        }
        return true;
      });
    }

    function computeDashboardInsights(posts, filters = {}) {
      const normalized = posts.map(normalizePostForInsights);
      const filtered = applyInsightFilters(normalized, filters);
      return {
        topScoreDelta: computeTopScoreDelta(filtered),
        subredditActivity: computeSubredditActivity(filtered),
        keywordFrequency: computeKeywordFrequency(filtered, filters),
        totalPosts: normalized.length,
        filteredPosts: filtered.length,
      };
    }

    function computeTopScoreDelta(posts) {
      return posts
        .slice()
        .sort((a, b) => (b.scoreDelta || 0) - (a.scoreDelta || 0))
        .slice(0, 5);
    }

    function computeSubredditActivity(posts) {
      const counts = new Map();
      for (const post of posts) {
        const sub = post.subreddit || 'unknown';
        counts.set(sub, (counts.get(sub) || 0) + 1);
      }
      return Array.from(counts.entries())
        .sort((a, b) => b[1] - a[1])
        .slice(0, 5)
        .map(([subreddit, count]) => ({ subreddit, count }));
    }

    function computeKeywordFrequency(posts, filters) {
      const counts = new Map();
      const tracked = (filters && filters.trackedKeywords) ? filters.trackedKeywords.map(keyword => keyword.toLowerCase()) : [];
      const keywordQuery = filters && filters.keywordQuery ? filters.keywordQuery.toLowerCase() : '';
      const trackAll = tracked.length === 0 && !keywordQuery;
      const targetSet = new Set(tracked);
      if (keywordQuery) {
        for (const token of keywordQuery.split(/\s+/)) {
          if (token) targetSet.add(token.toLowerCase());
        }
      }
      for (const post of posts) {
        const tokens = post.keywords.length > 0 ? post.keywords : extractInsightKeywords(post.title, post.selftext);
        for (const token of tokens) {
          if (!trackAll && !targetSet.has(token)) continue;
          if (INSIGHT_STOP_WORDS.has(token)) continue;
          counts.set(token, (counts.get(token) || 0) + 1);
        }
      }
      if (!trackAll && counts.size === 0) {
        for (const token of targetSet) {
          counts.set(token, 0);
        }
      }
      return Array.from(counts.entries())
        .sort((a, b) => b[1] - a[1])
        .slice(0, 10)
        .map(([keyword, count]) => ({ keyword, count }));
    }

    function formatScoreDelta(delta) {
      if (!Number.isFinite(delta)) return '0';
      if (delta > 0) return `+${delta}`;
      return String(delta);
    }

    function InsightsPanel({ insights, enabledInsights, onToggle, timeframeLabel }) {
      const activeKeys = Object.keys(enabledInsights).filter(key => enabledInsights[key]);
      return h('section', { className: 'bg-white rounded-2xl shadow p-3 flex flex-col gap-3 max-h-[40vh] overflow-auto' },
        h('header', { className: 'flex items-center justify-between gap-3' },
          h('div', null,
            h('h2', { className: 'font-semibold' }, 'Insights'),
            h('p', { className: 'text-xs text-zinc-500' }, timeframeLabel)
          ),
          h('div', { className: 'flex flex-wrap gap-2 text-xs text-zinc-600' },
            Object.keys(enabledInsights).map(key => h('label', { key, className: 'flex items-center gap-1 cursor-pointer select-none' },
              h('input', {
                type: 'checkbox',
                checked: enabledInsights[key],
                onChange: event => onToggle(key, event.target.checked)
              }),
              INSIGHT_LABELS[key]
            ))
          )
        ),
        activeKeys.length === 0 ? h('p', { className: 'text-sm text-zinc-500' }, 'Enable an insight above to populate this panel.') : null,
        activeKeys.includes('topScoreDelta') && h('article', { className: 'border border-zinc-200 rounded-xl p-3' },
          h('h3', { className: 'text-sm font-semibold mb-2' }, 'Top risers (score delta)'),
          insights.topScoreDelta.length === 0
            ? h('p', { className: 'text-xs text-zinc-500' }, 'No posts match the current filters.')
            : h('ol', { className: 'space-y-2 text-sm' },
                insights.topScoreDelta.map(post => h('li', { key: post.id, className: 'flex items-start gap-2' },
                  h('span', { className: 'px-1.5 py-0.5 rounded bg-green-100 text-green-700 text-xs font-semibold whitespace-nowrap' }, formatScoreDelta(post.scoreDelta)),
                  h('div', { className: 'flex-1' },
                    h('div', { className: 'font-semibold leading-snug' }, post.title || ''),
                    h('div', { className: 'text-[11px] text-zinc-500' }, `r/${post.subreddit}`)
                  )
                ))
              )
        ),
        activeKeys.includes('subredditActivity') && h('article', { className: 'border border-zinc-200 rounded-xl p-3' },
          h('h3', { className: 'text-sm font-semibold mb-2' }, 'Subreddits with most new posts'),
          insights.subredditActivity.length === 0
            ? h('p', { className: 'text-xs text-zinc-500' }, 'No posts match the current filters.')
            : h('ul', { className: 'space-y-2 text-sm' },
                insights.subredditActivity.map(entry => h('li', { key: entry.subreddit, className: 'flex items-center justify-between' },
                  h('span', { className: 'font-medium' }, `r/${entry.subreddit}`),
                  h('span', { className: 'text-xs text-zinc-500' }, `${entry.count} posts`)
                ))
              )
        ),
        activeKeys.includes('keywordFrequency') && h('article', { className: 'border border-zinc-200 rounded-xl p-3' },
          h('h3', { className: 'text-sm font-semibold mb-2' }, 'Keyword frequencies'),
          insights.keywordFrequency.length === 0
            ? h('p', { className: 'text-xs text-zinc-500' }, 'No keywords found for the current filters.')
            : h('ul', { className: 'space-y-2 text-sm' },
                insights.keywordFrequency.map(entry => h('li', { key: entry.keyword, className: 'flex items-center justify-between' },
                  h('span', { className: 'font-medium' }, entry.keyword),
                  h('span', { className: 'text-xs text-zinc-500' }, entry.count)
                ))
              )
        ),
        h('footer', { className: 'border-t border-dashed border-zinc-200 pt-2 mt-auto text-[11px] text-zinc-500' },
          `Showing ${insights.filteredPosts} of ${insights.totalPosts} posts`
        )
      );
    }

    function formatDateTime(timestamp) {
      const date = new Date(timestamp);
      if (Number.isNaN(date.getTime())) return '';
      return date.toLocaleString(undefined, {
        year: 'numeric',
        month: 'short',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit'
      });
    }

    function timeAgo(utcSeconds) {
      const now = Date.now() / 1000;
      const diff = Math.max(1, Math.floor(now - (utcSeconds || 0)));
      const units = [
        [31536000, 'year'],
        [2592000, 'month'],
        [604800, 'week'],
        [86400, 'day'],
        [3600, 'hour'],
        [60, 'minute'],
        [1, 'second'],
      ];
      for (const [seconds, name] of units) {
        if (diff >= seconds) {
          const count = Math.floor(diff / seconds);
          return `${count} ${name}${count > 1 ? 's' : ''} ago`;
        }
      }
      return 'just now';
    }

    function formatSubs(value) {
      if (!value && value !== 0) return '';
      if (value < 1000) return String(value);
      const units = ['k', 'M', 'B'];
      let unitIndex = -1;
      let val = value;
      while (val >= 1000 && unitIndex < units.length - 1) {
        val /= 1000;
        unitIndex += 1;
      }
      return `${val.toFixed(val >= 10 ? 0 : 1)}${units[unitIndex]}`;
    }

    function renderBody(post) {
      if (post.selftext_html) {
        const decoded = decodeHtml(post.selftext_html);
        return h('div', {
          className: 'prose prose-zinc max-w-none',
          dangerouslySetInnerHTML: { __html: decoded },
        });
      }
      if (post.selftext) {
        return h('div', { className: 'whitespace-pre-wrap text-[15px] leading-6 text-zinc-800' }, post.selftext);
      }
      return h('div', { className: 'text-sm text-zinc-500' }, '(No text body â€” link post)');
    }

    function decodeHtml(str) {
      return str
        .replace(/&lt;/g, '<')
        .replace(/&gt;/g, '>')
        .replace(/&amp;/g, '&')
        .replace(/&quot;/g, '"')
        .replace(/&#39;/g, "'");
    }

    // Client-side Reddit API fetching removed due to CORS issues

    // Removed unused client-side functions

    const root = createRoot(document.getElementById('root'));
    root.render(h(App));
  </script>
</body>
</html>
