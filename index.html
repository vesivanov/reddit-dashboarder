<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Reddit Three-Pane Dashboard</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
  <script src="https://cdn.tailwindcss.com"></script>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <style>
    body { font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial; }
    .post-body {
      font-size: 0.875rem;
      line-height: 1.6;
    }
  </style>
</head>
<body class="bg-zinc-50 min-h-screen text-zinc-900">
  <div id="root"></div>
  <script>
    const { useCallback, useEffect, useMemo, useRef, useState } = React;
    const { createRoot } = ReactDOM;
    const h = React.createElement;

    const DEFAULT_API_URL = "/api/reddit";
    const DEFAULT_SUBS = [];
    const STARTER_PACKS = [
      {
        id: 'tech-news',
        label: 'Tech news',
        description: 'Keep an eye on what\'s shipping across consumer and enterprise tech.',
        subs: ['technology', 'gadgets', 'futurology', 'programming'],
      },
      {
        id: 'design-inspo',
        label: 'Design inspiration',
        description: 'Daily visuals, UX breakdowns, and palette cleansers.',
        subs: ['design', 'web_design', 'graphic_design', 'productdesign'],
      },
      {
        id: 'data-ai',
        label: 'Data & AI',
        description: 'Track the fast-moving ML landscape for teams and practitioners.',
        subs: ['machinelearning', 'datascience', 'openai', 'artificial'],
      },
    ];
    const POPULAR_SUBREDDITS = [
      'askreddit',
      'worldnews',
      'news',
      'technology',
      'programming',
      'todayilearned',
      'design',
      'dataisbeautiful',
      'futurology',
      'productdesign',
      'webdev',
    ];
    const UPVOTE_PRESETS = ['any', 10, 50, 100, 500];
    const COMMENT_PRESETS = ['any', 5, 20, 50, 100];
    const AUTO_REFRESH_OPTIONS = [5, 10, 15, 30, 45, 60];
    const MIN_AUTO_REFRESH_MINUTES = 5;

    function App() {
      const [subs, setSubs] = useState(() => {
        try {
          // Try primary storage first
          let saved = localStorage.getItem('dashboard_subs');
          if (saved) return JSON.parse(saved);
          
          // Fallback to backup storage
          saved = localStorage.getItem('dashboard_subs_backup');
          if (saved) {
            const parsed = JSON.parse(saved);
            // Restore to primary storage
            localStorage.setItem('dashboard_subs', saved);
            return parsed;
          }
        } catch (error) {
          console.warn('Unable to parse saved subs', error);
        }
        return DEFAULT_SUBS;
      });
      const [subsInput, setSubsInput] = useState(() => {
        try {
          const saved = localStorage.getItem('dashboard_subs');
          if (saved) {
            const subs = JSON.parse(saved);
            return subs.join(', ');
          }
        } catch (error) {
          console.warn('Unable to parse saved subs', error);
        }
        return '';
      });
      const [mode, setMode] = useState('new');
      const [time, setTime] = useState('day');
      const [days, setDays] = useState(1);
      const [limit, setLimit] = useState(100);
      const [maxPages, setMaxPages] = useState(() => {
        try {
          const saved = localStorage.getItem('dashboard_max_pages');
          if (saved) return Math.max(1, Math.min(500, Number(saved) || 5));
        } catch (error) {}
        return 100;
      });
      const [loading, setLoading] = useState(false);
      const [autoRefreshEnabled, setAutoRefreshEnabled] = useState(() => {
        try {
          const saved = localStorage.getItem('dashboard_auto_refresh_enabled');
          return saved === '1';
        } catch (error) {
          return false;
        }
      });
      const [autoRefreshInterval, setAutoRefreshInterval] = useState(() => {
        try {
          const saved = Number(localStorage.getItem('dashboard_auto_refresh_interval'));
          if (Number.isFinite(saved)) {
            return Math.min(60, Math.max(MIN_AUTO_REFRESH_MINUTES, Math.round(saved)));
          }
        } catch (error) {}
        return 10;
      });
      const [error, setError] = useState('');
      const [needsAuth, setNeedsAuth] = useState(false);
      const [data, setData] = useState([]);
      const [selectedSub, setSelectedSub] = useState('ALL');
      const [selectedPost, setSelectedPost] = useState(null);
      const [fetchedAt, setFetchedAt] = useState(null);
      const [keyword, setKeyword] = useState('');
      const [fetchMethod, setFetchMethod] = useState('server'); // Track which method was used
      const [authenticated, setAuthenticated] = useState(false);
      const [authChecking, setAuthChecking] = useState(true);
      const [subsExpanded, setSubsExpanded] = useState(() => {
        try {
          const saved = localStorage.getItem('dashboard_subs');
          if (!saved) return true;
          const parsed = JSON.parse(saved);
          return Array.isArray(parsed) ? parsed.length === 0 : true;
        } catch (error) {
          return true;
        }
      });
      const [keywordExpanded, setKeywordExpanded] = useState(false);
      const [filtersExpanded, setFiltersExpanded] = useState(false);
      const [starterPackOpen, setStarterPackOpen] = useState(false);
      const [quickAddValue, setQuickAddValue] = useState('');
      const [minUpvoteFilter, setMinUpvoteFilter] = useState('');
      const [maxUpvoteFilter, setMaxUpvoteFilter] = useState('');
      const [minCommentFilter, setMinCommentFilter] = useState('');
      const [maxCommentFilter, setMaxCommentFilter] = useState('');
      const [showAdvancedFilters, setShowAdvancedFilters] = useState(false);
      const [sortBy, setSortBy] = useState('date');
      const [sortOrder, setSortOrder] = useState('desc');
      const [nextRefreshAt, setNextRefreshAt] = useState(null);
      const [lastAutoRefreshAt, setLastAutoRefreshAt] = useState(null);
      const [onboardingDismissed, setOnboardingDismissed] = useState(() => {
        try {
          return localStorage.getItem('dashboard_onboarding_dismissed') === '1';
        } catch (error) {
          return false;
        }
      });
      const subsInputRef = useRef(null);
      const loadingRef = useRef(false);

      useEffect(() => {
        loadingRef.current = loading;
      }, [loading]);

      const ensureSubsInputFocus = useCallback(() => {
        setTimeout(() => {
          const node = subsInputRef.current;
          if (node) {
            node.focus();
            node.select();
          }
        }, 80);
      }, []);

      const handleAddSubredditClick = useCallback(() => {
        setSubsExpanded(true);
        if (!onboardingDismissed) {
          setOnboardingDismissed(true);
        }
        ensureSubsInputFocus();
      }, [ensureSubsInputFocus, onboardingDismissed]);

      const handleApplyStarterPack = useCallback((pack) => {
        if (!pack || !Array.isArray(pack.subs)) return;
        setSubs(prev => mergeSubredditLists(prev, pack.subs));
        setSubsExpanded(true);
        setOnboardingDismissed(true);
        ensureSubsInputFocus();
      }, [ensureSubsInputFocus]);

      const handleSuggestedSub = useCallback((name) => {
        if (!name) return;
        setSubs(prev => mergeSubredditLists(prev, [name]));
        setSubsExpanded(true);
        if (!onboardingDismissed) {
          setOnboardingDismissed(true);
        }
        ensureSubsInputFocus();
      }, [ensureSubsInputFocus, onboardingDismissed]);

      const handleQuickAddSubmit = useCallback(() => {
        const value = quickAddValue.trim();
        if (!value) return;
        handleSuggestedSub(value);
        setQuickAddValue('');
      }, [handleSuggestedSub, quickAddValue]);

      const filtersActive = [minUpvoteFilter, maxUpvoteFilter, minCommentFilter, maxCommentFilter]
        .some(value => value && value.trim() !== '');

      useEffect(() => {
        try {
          // Save to both primary and backup storage
          const subsJson = JSON.stringify(subs);
          localStorage.setItem('dashboard_subs', subsJson);
          localStorage.setItem('dashboard_subs_backup', subsJson);

          // Also save a timestamp for debugging
          localStorage.setItem('dashboard_subs_last_saved', new Date().toISOString());
        } catch (storageError) {
          console.warn('Unable to persist subs', storageError);
        }
      }, [subs]);

      useEffect(() => {
        // Sync subsInput when subs changes (e.g., from localStorage)
        setSubsInput(subs.join(', '));
      }, [subs]);

      useEffect(() => {
        try { localStorage.setItem('dashboard_max_pages', String(maxPages)); } catch {}
      }, [maxPages]);

      useEffect(() => {
        try { localStorage.setItem('dashboard_auto_refresh_enabled', autoRefreshEnabled ? '1' : '0'); } catch {}
      }, [autoRefreshEnabled]);

      useEffect(() => {
        try { localStorage.setItem('dashboard_auto_refresh_interval', String(autoRefreshInterval)); } catch {}
      }, [autoRefreshInterval]);

      useEffect(() => {
        try { localStorage.setItem('dashboard_onboarding_dismissed', onboardingDismissed ? '1' : '0'); } catch {}
      }, [onboardingDismissed]);

      useEffect(() => {
        if (subs.length > 0 && !onboardingDismissed) {
          setOnboardingDismissed(true);
        }
      }, [subs.length, onboardingDismissed]);

      useEffect(() => {
        let cancelled = false;

        async function checkAuth() {
          setAuthChecking(true);
          try {
            const response = await fetch('/api/auth/status', { cache: 'no-store' });
            if (!response.ok) throw new Error('Failed to check auth status');
            const payload = await response.json();
            if (!cancelled) {
              setAuthenticated(Boolean(payload.authenticated));
            }
          } catch (statusError) {
            if (!cancelled) {
              setAuthenticated(false);
            }
          } finally {
            if (!cancelled) {
              setAuthChecking(false);
            }
          }
        }

        checkAuth();

        return () => {
          cancelled = true;
        };
      }, []);

      const allPosts = useMemo(() => {
        const rows = [];
        for (const group of data) {
          for (const post of group.posts || []) {
            rows.push(post);
          }
        }
        rows.sort((a, b) => (b.created_utc || 0) - (a.created_utc || 0));
        return rows;
      }, [data]);

      const filteredBySub = useMemo(() => {
        if (selectedSub === 'ALL') return allPosts;
        const selected = selectedSub.toLowerCase();
        return allPosts.filter(post => post.subreddit?.toLowerCase() === selected);
      }, [allPosts, selectedSub]);

      const visiblePosts = useMemo(() => {
        const q = keyword.trim().toLowerCase();
        const minScore = parseNumberFilter(minUpvoteFilter);
        const maxScore = parseNumberFilter(maxUpvoteFilter);
        const minCommentsValue = parseNumberFilter(minCommentFilter);
        const maxCommentsValue = parseNumberFilter(maxCommentFilter);

        const filtered = filteredBySub.filter(post => {
          if (q) {
            const title = post.title ? post.title.toLowerCase() : '';
            const selftext = post.selftext ? post.selftext.toLowerCase() : '';
            if (!title.includes(q) && !selftext.includes(q)) {
              return false;
            }
          }

          const rawScore = Number(post.score);
          const score = Number.isFinite(rawScore) ? rawScore : 0;
          if (minScore !== null && score < minScore) return false;
          if (maxScore !== null && score > maxScore) return false;

          const rawComments = Number(post.num_comments);
          const comments = Number.isFinite(rawComments) ? rawComments : 0;
          if (minCommentsValue !== null && comments < minCommentsValue) return false;
          if (maxCommentsValue !== null && comments > maxCommentsValue) return false;

          return true;
        });

        const multiplier = sortOrder === 'asc' ? 1 : -1;

        return [...filtered].sort((a, b) => {
          const aDate = Number(a.created_utc) || 0;
          const bDate = Number(b.created_utc) || 0;
          const aScore = Number(a.score) || 0;
          const bScore = Number(b.score) || 0;
          const aComments = Number(a.num_comments) || 0;
          const bComments = Number(b.num_comments) || 0;

          let delta = 0;
          switch (sortBy) {
            case 'upvotes':
              delta = aScore - bScore;
              break;
            case 'comments':
              delta = aComments - bComments;
              break;
            case 'date':
            default:
              delta = aDate - bDate;
              break;
          }

          if (delta === 0) {
            const fallback = aDate - bDate;
            if (fallback === 0) return 0;
            return sortOrder === 'asc' ? fallback : -fallback;
          }

          return delta * multiplier;
        });
      }, [filteredBySub, keyword, minUpvoteFilter, maxUpvoteFilter, minCommentFilter, maxCommentFilter, sortBy, sortOrder]);

      const { maxScore, maxComments } = useMemo(() => {
        let maxScore = 0;
        let maxComments = 0;
        for (const post of allPosts) {
          const score = Number(post.score);
          const comments = Number(post.num_comments);
          if (Number.isFinite(score)) {
            maxScore = Math.max(maxScore, score);
          }
          if (Number.isFinite(comments)) {
            maxComments = Math.max(maxComments, comments);
          }
        }
        return { maxScore, maxComments };
      }, [allPosts]);

      const statusSummary = useMemo(() => {
        const pieces = [
          `Fetched: ${fetchedAt ? formatDateTime(fetchedAt) : '—'}`,
          `Posts: ${visiblePosts.length}`,
          `Mode: ${mode}${mode === 'top' ? ` (t=${time})` : ''}`,
          `Range: ${days} day(s)`,
          `Method: ${fetchMethod === 'client' ? 'Client-side' : 'Server'}`,
        ];

        if (autoRefreshEnabled) {
          let summary = `Auto-refresh: every ${autoRefreshInterval} min`;
          if (nextRefreshAt) {
            summary += ` (next ${formatTimeUntil(nextRefreshAt)})`;
          } else if (!subs.length) {
            summary += ' (waiting for subreddits)';
          } else if (loading) {
            summary += ' (running…)';
          }
          if (lastAutoRefreshAt) {
            summary += ` • Last ${timeAgo(lastAutoRefreshAt / 1000)}`;
          }
          pieces.push(summary);
        } else {
          pieces.push('Auto-refresh: off');
        }

        return pieces.join(' • ');
      }, [fetchedAt, visiblePosts.length, mode, time, days, fetchMethod, autoRefreshEnabled, autoRefreshInterval, nextRefreshAt, lastAutoRefreshAt, subs.length, loading]);

      const subMetaMap = useMemo(() => {
        const map = new Map();
        for (const group of data) {
          map.set(group.subreddit, group.meta || null);
        }
        return map;
      }, [data]);
      const subPartialMap = useMemo(() => {
        const map = new Map();
        for (const group of data) {
          map.set(group.subreddit, Boolean(group.partial));
        }
        return map;
      }, [data]);

      const refresh = useCallback(async (options = {}) => {
        const triggeredByAuto = Boolean(options.triggeredByAuto);
        if (!subs.length) {
          setNeedsAuth(false);
          setError('Please add at least one subreddit.');
          setData([]);
          setFetchedAt(null);
          setNextRefreshAt(null);
          return;
        }

        setLoading(true);
        setError('');
        setNeedsAuth(false);
        setSelectedPost(null);
        const controller = new AbortController();
        const timeoutMs = Math.min(45000, 5000 + subs.length * 3000);
        const timeoutId = setTimeout(() => controller.abort(), timeoutMs);

        try {
          const params = new URLSearchParams({
            subs: subs.join(','),
            mode,
            time,
            days: String(days),
            // If many subreddits are requested, cap per-page limit to reduce load
            limit: String(subs.length > 6 ? Math.min(50, limit) : limit)
          });
          if (mode === 'new') {
            // Lower max pages by default for many subs to avoid timeouts
            const effMaxPages = subs.length > 6 ? Math.min(10, maxPages) : maxPages;
            params.set('max_pages', String(effMaxPages));
          }

          // Use server API directly (client-side has CORS issues)
          setFetchMethod('server');
          const qs = new URLSearchParams(params);
          const response = await fetch(`${DEFAULT_API_URL}?${qs.toString()}`, { cache: 'no-store', signal: controller.signal });

          if (response.status === 401) {
            setNeedsAuth(true);
            setAuthenticated(false);
            setAuthChecking(false);
            setError('Sign in with Reddit to fetch your dashboard.');
            setData([]);
            setFetchedAt(null);
            return;
          }

          if (!response.ok) throw new Error(`HTTP ${response.status}`);

          const rateLimitedHeader = response.headers.get('X-Rate-Limited') === '1';
          const payload = await response.json();
          if (rateLimitedHeader || payload.rate_limited) {
            setError('Reddit is rate limiting right now. Some subreddits returned no data. Try fewer subreddits, lower max pages, or wait a minute.');
          }
          const results = Array.isArray(payload.results) ? payload.results : [];
          const perSub = subs.map(sub => {
            const match = results.find(r => (r.subreddit || '').toLowerCase() === sub.toLowerCase());
            if (match) return {
              subreddit: match.subreddit,
              meta: match.meta || null,
              posts: match.posts || [],
              partial: Boolean(match.partial),
              error: match.error || null,
            };
            return { subreddit: sub, posts: [], meta: null, partial: false, error: null };
          });
          setNeedsAuth(false);
          setAuthenticated(true);
          setAuthChecking(false);
          setData(perSub);
          setFetchedAt(Date.now());
        } catch (fetchError) {
          setNeedsAuth(false);
          if (fetchError && fetchError.name === 'AbortError') {
            const seconds = Math.round(timeoutMs / 1000);
            setError(`Request timed out (${seconds}s). Reddit may be rate limiting. Try fewer subreddits or try again.`);
          } else if (fetchError && typeof fetchError.message === 'string' && fetchError.message.toLowerCase().includes('rate')) {
            setError('Reddit is rate limiting right now. Please wait a minute and try again.');
          } else {
            setError(fetchError.message || 'Failed to fetch');
          }
          setData([]);
          setFetchedAt(null);
        } finally {
          clearTimeout(timeoutId);
          setLoading(false);
          if (autoRefreshEnabled && subs.length) {
            setNextRefreshAt(Date.now() + autoRefreshInterval * 60 * 1000);
          } else {
            setNextRefreshAt(null);
          }
          if (triggeredByAuto) {
            setLastAutoRefreshAt(Date.now());
          }
        }
      }, [subs, mode, time, days, limit, maxPages, autoRefreshEnabled, autoRefreshInterval]);

      const refreshRef = useRef(refresh);

      useEffect(() => {
        refreshRef.current = refresh;
      }, [refresh]);

      useEffect(() => {
        if (!autoRefreshEnabled) {
          setLastAutoRefreshAt(null);
        }
      }, [autoRefreshEnabled]);

      useEffect(() => {
        if (!autoRefreshEnabled || !subs.length) {
          setNextRefreshAt(null);
          return () => {};
        }

        const intervalMs = Math.max(MIN_AUTO_REFRESH_MINUTES, autoRefreshInterval) * 60 * 1000;
        setNextRefreshAt(Date.now() + intervalMs);
        let cancelled = false;

        const triggerRefresh = () => {
          if (cancelled) return;
          if (loadingRef.current) return;
          if (!subs.length) return;
          refreshRef.current({ triggeredByAuto: true });
        };

        const kickoff = setTimeout(triggerRefresh, 200);
        const intervalId = setInterval(triggerRefresh, intervalMs);

        return () => {
          cancelled = true;
          clearTimeout(kickoff);
          clearInterval(intervalId);
        };
      }, [autoRefreshEnabled, autoRefreshInterval, subs.length]);

      return h('div', { className: 'max-w-7xl mx-auto p-4 space-y-6' },
        h('header', { className: 'space-y-4' },
          h('div', { className: 'flex flex-col gap-2 md:flex-row md:items-center md:justify-between' },
            h('div', { className: 'space-y-1' },
              h('h1', { className: 'text-2xl font-extrabold' }, 'Reddit Dashboarder'),
              h('p', { className: 'text-zinc-600 text-sm' }, 'Three-pane • Keyword filter • Day / 3 Days / Week • Full post body + subreddit stats')
            ),
            h('div', { className: 'flex flex-wrap items-center gap-2' },
              h('button', {
                onClick: handleAddSubredditClick,
                className: 'px-4 py-2 rounded-xl border border-blue-200 bg-blue-50 text-blue-700 font-semibold shadow-sm hover:bg-blue-100 transition-colors'
              }, subs.length ? 'Manage subreddits' : 'Add subreddits')
            )
          ),
          h('div', { className: 'bg-white rounded-2xl shadow-sm p-4 space-y-4' },
            h('div', { className: 'flex flex-col gap-2 lg:flex-row lg:items-center lg:justify-between' },
              error
                ? h('div', { className: 'px-3 py-2 rounded-xl border border-rose-200 bg-rose-50 text-sm font-semibold text-rose-700' }, `Error: ${error}`)
                : loading
                  ? h('div', { className: 'px-3 py-2 rounded-xl border border-zinc-200 bg-zinc-50 text-sm font-semibold text-zinc-600' }, 'Fetching latest posts…')
                  : h('div', { className: 'text-sm text-zinc-600' }, statusSummary),
              h('div', { className: 'flex flex-wrap items-center gap-3' },
                h('label', { className: 'flex items-center gap-2 text-sm font-semibold text-zinc-700' },
                  h('input', {
                    type: 'checkbox',
                    className: 'w-4 h-4 rounded border-zinc-300 text-indigo-600 focus:ring-indigo-500',
                    checked: autoRefreshEnabled,
                    onChange: event => setAutoRefreshEnabled(event.target.checked),
                    title: subs.length ? 'Toggle automatic refresh' : 'Add at least one subreddit to start auto-refreshing'
                  }),
                  'Auto-refresh'
                ),
                h('select', {
                  className: 'border rounded-lg px-2 py-1 text-sm',
                  value: autoRefreshInterval,
                  disabled: !autoRefreshEnabled,
                  onChange: event => {
                    const next = Number(event.target.value);
                    if (Number.isFinite(next)) {
                      setAutoRefreshInterval(Math.min(60, Math.max(MIN_AUTO_REFRESH_MINUTES, Math.round(next))));
                    }
                  }
                },
                  AUTO_REFRESH_OPTIONS.map(option =>
                    h('option', { key: option, value: option }, `${option} min`)
                  )
                ),
                h('button', {
                  onClick: () => refresh(),
                  className: 'px-4 py-2 rounded-lg bg-black text-white text-sm font-semibold shadow disabled:opacity-50',
                  disabled: loading
                }, loading ? 'Fetching…' : 'Refresh'),
                authChecking
                  ? h('div', {
                      className: 'px-3 py-2 rounded-lg border border-dashed border-zinc-300 bg-zinc-50 text-sm text-zinc-500 flex items-center gap-2'
                    },
                      h('div', { className: 'w-3 h-3 border-2 border-zinc-300 border-t-zinc-600 rounded-full animate-spin' }),
                      'Checking auth…'
                    )
                  : authenticated
                    ? h('button', {
                        type: 'button',
                        className: 'px-3 py-2 rounded-lg border border-zinc-200 bg-white text-zinc-800 hover:bg-zinc-50 transition-colors text-sm font-semibold shadow-sm',
                        onClick: () => { window.location.href = '/api/auth/logout'; }
                      }, 'Sign out')
                    : h('button', {
                        type: 'button',
                        className: 'px-3 py-2 rounded-lg border border-zinc-200 bg-white text-zinc-800 hover:bg-zinc-50 transition-colors text-sm font-semibold shadow-sm',
                        onClick: () => { window.location.href = '/api/auth/start'; }
                      }, 'Sign in')
              )
            ),
            h('div', { className: 'space-y-3' },
              h('button', {
                type: 'button',
                className: 'inline-flex items-center gap-2 text-sm font-semibold text-zinc-800 px-3 py-2 rounded-lg border border-zinc-200 bg-white hover:bg-zinc-50 transition-colors',
                onClick: () => setFiltersExpanded(open => !open)
              },
                h('span', { className: 'inline-block w-2.5 h-2.5 rounded-full border border-zinc-300 bg-white' }),
                filtersExpanded ? 'Close filters' : 'Open filters'
              ),
              filtersExpanded
                ? h('div', { className: 'grid gap-3 sm:grid-cols-2 lg:grid-cols-4' },
                    h('label', { className: 'flex flex-col gap-1 text-sm font-medium text-zinc-700' },
                      'Listing mode',
                      h('select', {
                        className: 'border rounded-lg px-3 py-2 text-sm font-normal text-zinc-800',
                        value: mode,
                        onChange: event => setMode(event.target.value)
                      },
                        h('option', { value: 'new' }, 'new'),
                        h('option', { value: 'top' }, 'top')
                      )
                    ),
                    h('label', { className: 'flex flex-col gap-1 text-sm font-medium text-zinc-700' },
                      'Top range',
                      h('select', {
                        className: 'border rounded-lg px-3 py-2 text-sm font-normal text-zinc-800 disabled:text-zinc-400',
                        value: time,
                        onChange: event => setTime(event.target.value),
                        disabled: mode !== 'top'
                      },
                        h('option', { value: 'hour' }, 'hour'),
                        h('option', { value: 'day' }, 'day'),
                        h('option', { value: 'week' }, 'week'),
                        h('option', { value: 'month' }, 'month')
                      )
                    ),
                    h('label', { className: 'flex flex-col gap-1 text-sm font-medium text-zinc-700' },
                      'Lookback window',
                      h('select', {
                        className: 'border rounded-lg px-3 py-2 text-sm font-normal text-zinc-800',
                        value: days,
                        onChange: event => setDays(Number(event.target.value) || 1)
                      },
                        h('option', { value: 1 }, 'Day'),
                        h('option', { value: 3 }, '3 Days'),
                        h('option', { value: 7 }, 'Week')
                      )
                    ),
                    h('label', { className: 'flex flex-col gap-1 text-sm font-medium text-zinc-700' },
                      'Page limit',
                      h('select', {
                        className: 'border rounded-lg px-3 py-2 text-sm font-normal text-zinc-800',
                        value: maxPages,
                        onChange: event => setMaxPages(Math.max(1, Math.min(500, Number(event.target.value) || 100)))
                      },
                        h('option', { value: 5 }, 'Max pages: 5'),
                        h('option', { value: 10 }, 'Max pages: 10'),
                        h('option', { value: 20 }, 'Max pages: 20'),
                        h('option', { value: 50 }, 'Max pages: 50'),
                        h('option', { value: 100 }, 'Max pages: 100'),
                        h('option', { value: 200 }, 'Max pages: 200')
                      )
                    )
                  )
                : null
            )
          )
        ),
        needsAuth ? h('div', { className: 'mb-3 rounded-2xl border border-amber-300 bg-amber-50 text-amber-900 px-4 py-3 space-y-1' },
          h('p', { className: 'font-semibold' }, 'Sign in required'),
          h('p', { className: 'text-sm' }, 'Sign in with Reddit to load personalized data for your dashboard.'),
        ) : null,
        subs.length === 0 && !onboardingDismissed ? h('section', { className: 'mb-4' },
          h('div', { className: 'bg-white border border-blue-200 rounded-3xl shadow-sm p-5 space-y-4' },
            h('div', { className: 'space-y-2' },
              h('h2', { className: 'text-xl font-bold text-blue-700' }, 'Start your dashboard in minutes'),
              h('p', { className: 'text-sm text-zinc-600 max-w-2xl' }, 'Add the communities you care about. Browse curated bundles or paste your own list — everything is saved locally for next time.')
            ),
            h('div', { className: 'flex flex-wrap gap-2' },
              h('button', {
                className: 'inline-flex items-center justify-center rounded-lg bg-blue-600 px-4 py-2 text-sm font-semibold text-white shadow transition-colors hover:bg-blue-700',
                onClick: () => {
                  setStarterPackOpen(true);
                  setOnboardingDismissed(true);
                }
              }, 'Browse starter packs'),
              h('button', {
                className: 'inline-flex items-center justify-center rounded-lg border border-blue-200 px-4 py-2 text-sm font-semibold text-blue-700 hover:bg-blue-50 transition-colors',
                onClick: handleAddSubredditClick
              }, 'Add manually'),
              h('button', {
                className: 'inline-flex items-center justify-center rounded-lg border border-transparent px-4 py-2 text-sm font-semibold text-blue-500 hover:text-blue-700',
                onClick: () => setOnboardingDismissed(true)
              }, 'Maybe later')
            ),
            h('p', { className: 'text-xs text-zinc-500' }, 'Tip: You can export or import your setup anytime from the Subreddits panel.')
          )
        ) : null,
        h('div', { className: 'mb-3 space-y-2' },
          h('div', { className: 'bg-white rounded-2xl shadow p-3' },
            h('button', {
              className: 'w-full flex items-center justify-between text-left',
              onClick: () => setSubsExpanded(!subsExpanded)
            },
              h('div', { className: 'flex items-center gap-2' },
                h('span', { className: 'font-medium' }, 'Subreddits'),
                subs.length > 0 && h('span', { className: 'px-2 py-0.5 rounded-full bg-blue-100 text-blue-700 text-xs' }, `${subs.length} added`)
              ),
              h('span', { className: 'text-zinc-400' }, subsExpanded ? '▼' : '▶')
            ),
            subsExpanded && h('div', { className: 'mt-3 pt-3 border-t border-zinc-200 space-y-4' },
              h('textarea', {
                className: 'w-full border rounded-lg px-3 py-2 text-sm',
                rows: 3,
                value: subsInput,
                placeholder: 'Enter subreddit names separated by commas (e.g., programming, r/technology, webdev)',
                onChange: event => setSubsInput(event.target.value),
                onBlur: event => {
                  const list = uniqueNormalizedSubreddits(event.target.value);
                  setSubs(list);
                  try {
                    localStorage.setItem('dashboard_subs', JSON.stringify(list));
                    localStorage.setItem('dashboard_subs_backup', JSON.stringify(list));
                  } catch (e) {
                    console.warn('Failed to save subreddits:', e);
                  }
                },
                ref: subsInputRef
              }),
              h('p', { className: 'text-xs text-zinc-500' }, 'Separate each community with a comma. Your list stays in this browser so it\'s ready whenever you return.'),
              h('div', { className: 'flex flex-col gap-3 sm:flex-row sm:items-end sm:justify-between' },
                h('button', {
                  type: 'button',
                  className: 'inline-flex items-center justify-center rounded-lg border border-indigo-200 bg-indigo-50 px-3 py-2 text-sm font-semibold text-indigo-700 hover:bg-indigo-100 transition-colors',
                  onClick: () => setStarterPackOpen(true)
                }, 'Browse starter packs'),
                h('div', { className: 'flex-1 sm:max-w-sm w-full' },
                  h('label', { className: 'block text-xs font-semibold text-zinc-600 uppercase tracking-wide mb-1' }, 'Quick add from popular'),
                  h('div', { className: 'flex gap-2' },
                    h('input', {
                      className: 'flex-1 border rounded-lg px-3 py-2 text-sm',
                      list: 'popular-subreddits',
                      placeholder: 'Start typing to search popular subreddits…',
                      value: quickAddValue,
                      onChange: event => setQuickAddValue(event.target.value),
                      onKeyDown: event => {
                        if (event.key === 'Enter') {
                          event.preventDefault();
                          handleQuickAddSubmit();
                        }
                      }
                    }),
                    h('button', {
                      type: 'button',
                      className: 'px-3 py-2 rounded-lg bg-black text-white text-sm font-semibold shadow disabled:opacity-40',
                      onClick: handleQuickAddSubmit,
                      disabled: !quickAddValue.trim()
                    }, 'Add')
                  ),
                  h('datalist', { id: 'popular-subreddits' },
                    POPULAR_SUBREDDITS.map(sub =>
                      h('option', { key: sub, value: `r/${sub}` })
                    )
                  )
                )
              ),
              h('details', { className: 'rounded-xl border border-zinc-200 bg-zinc-50 p-3 text-sm text-zinc-600' },
                h('summary', { className: 'font-semibold cursor-pointer select-none' }, 'More actions'),
                h('div', { className: 'mt-2 flex flex-wrap gap-2' },
                  h('button', {
                    className: 'px-3 py-1.5 rounded-lg border border-zinc-200 bg-white text-xs font-semibold text-zinc-700 hover:bg-zinc-100',
                    onClick: () => {
                      const backup = JSON.stringify({ subs, maxPages });
                      navigator.clipboard.writeText(backup);
                      alert('Settings copied to clipboard.');
                    }
                  }, 'Copy setup'),
                  h('button', {
                    className: 'px-3 py-1.5 rounded-lg border border-zinc-200 bg-white text-xs font-semibold text-zinc-700 hover:bg-zinc-100',
                    onClick: () => {
                      const input = prompt('Paste your settings backup:');
                      if (input) {
                        try {
                          const parsed = JSON.parse(input);
                          if (parsed.subs) setSubs(parsed.subs);
                          if (parsed.maxPages) setMaxPages(parsed.maxPages);
                          alert('Settings restored.');
                        } catch (e) {
                          alert('Invalid backup format');
                        }
                      }
                    }
                  }, 'Restore from backup')
                )
              )
            )
          ),
          h('div', { className: 'bg-white rounded-2xl shadow p-3' },
            h('button', {
              className: 'w-full flex items-center justify-between text-left',
              onClick: () => setKeywordExpanded(!keywordExpanded)
            },
              h('div', { className: 'flex items-center gap-2' },
                h('span', { className: 'font-medium' }, 'Search'),
                keyword && h('span', { className: 'px-2 py-0.5 rounded-full bg-green-100 text-green-700 text-xs' }, `"${keyword}"`)
              ),
              h('span', { className: 'text-zinc-400' }, keywordExpanded ? '▼' : '▶')
            ),
            keywordExpanded && h('div', { className: 'mt-3 pt-3 border-t border-zinc-200' },
              h('input', {
                className: 'w-full border rounded-lg px-3 py-2 text-sm',
                value: keyword,
                onChange: event => setKeyword(event.target.value),
                placeholder: 'Type a keyword or phrase to search posts...'
              })
            )
          )
        ),
        h('div', { className: 'grid grid-cols-1 lg:grid-cols-12 gap-4' },
          h('aside', { className: 'lg:col-span-2 bg-white rounded-2xl shadow p-3 lg:p-2 lg:text-sm' },
            h('div', { className: 'flex items-center justify-between mb-3 lg:mb-2' },
              h('h2', { className: 'font-semibold text-base lg:text-sm' }, 'Subreddits'),
              h('button', {
                className: 'text-xs px-2 py-1 rounded-lg bg-zinc-100 hover:bg-zinc-200',
                onClick: () => setSelectedSub('ALL')
              }, 'All')
            ),
            subs.length === 0
              ? h('div', { className: 'text-sm lg:text-xs text-zinc-500 italic text-center py-8 lg:py-6' },
                  h('div', { className: 'space-y-2' },
                    h('div', null, 'No subreddits added yet'),
                    h('div', { className: 'text-xs' }, 'Use “Add subreddits” to choose a starter pack or enter your own list')
                  )
                )
              : h('div', { className: 'space-y-2 lg:space-y-1.5 max-h-[70vh] overflow-auto' },
                  subs.map(sub => {
                    const meta = subMetaMap.get(sub) || {};
                    const capped = subPartialMap.get(sub);
                    const postCount = allPosts.filter(post => post.subreddit?.toLowerCase() === sub.toLowerCase()).length;
                    return h('div', { key: sub, className: 'border border-zinc-200 rounded-lg p-3 lg:p-2 hover:border-zinc-300 transition-colors' },
                      h('button', {
                        onClick: () => setSelectedSub(sub),
                        className: `w-full text-left ${selectedSub === sub ? 'font-semibold' : ''}`
                      },
                        h('div', { className: 'flex items-center justify-between mb-2 lg:mb-1.5' },
                          h('span', { className: 'text-sm lg:text-xs font-medium' }, `r/${sub}`),
                          h('span', { className: 'text-xs text-zinc-500' }, `${postCount} posts`)
                        ),
                        h('div', { className: 'flex items-center gap-2 lg:gap-1.5 text-xs text-zinc-500' },
                          h('span', { className: 'leading-tight' }, `${formatSubs(meta.subscribers)} subscribers`),
                          meta.active_user_count && h('span', { className: 'leading-tight' }, `• ${formatSubs(meta.active_user_count)} active`),
                          capped && h('span', { className: 'px-1.5 py-0.5 rounded bg-orange-100 text-orange-700 border border-orange-200' }, 'capped')
                        )
                      )
                    );
                  })
                ),
            subs.length > 0 && h('p', { className: 'text-[11px] text-zinc-500 mt-3 pt-3 border-t border-zinc-200' }, 'Active ≈ users online/active (15m window if provided by Reddit). Weekly contributors aren\'t available via public endpoints.')
          ),
          h('main', { className: 'lg:col-span-6 bg-white rounded-2xl shadow p-4 max-h-[80vh] overflow-auto space-y-4' },
            h('h2', { className: 'font-semibold' }, selectedSub === 'ALL' ? 'Latest from all' : `Latest in r/${selectedSub}`),
            h('div', { className: 'space-y-3' },
              h('div', { className: 'grid gap-3 md:grid-cols-3' },
                h('div', { className: 'rounded-2xl border border-zinc-200 bg-zinc-50 p-3 space-y-2' },
                  h('p', { className: 'text-xs font-semibold uppercase tracking-wide text-zinc-500' }, 'Score filters'),
                  h('div', { className: 'flex flex-wrap gap-2' },
                    UPVOTE_PRESETS.map(value => {
                      const label = value === 'any' ? 'Any' : `${value}+`;
                      const isActive = value === 'any' ? minUpvoteFilter === '' : minUpvoteFilter === String(value);
                      return h('button', {
                        key: `score-${value}`,
                        type: 'button',
                        className: `px-3 py-1.5 rounded-full border text-xs font-semibold transition-colors ${isActive ? 'border-indigo-500 bg-indigo-100 text-indigo-700' : 'border-transparent bg-white text-zinc-600 hover:border-indigo-200'}`,
                        onClick: () => setMinUpvoteFilter(value === 'any' ? '' : String(value))
                      }, label);
                    })
                  ),
                  h('div', { className: 'flex items-center gap-2' },
                    h('span', { className: 'text-[11px] font-semibold uppercase tracking-wide text-zinc-500' }, 'Custom'),
                    h('input', {
                      type: 'number',
                      inputMode: 'numeric',
                      className: 'flex-1 border rounded-lg px-2 py-1 text-xs',
                      value: minUpvoteFilter,
                      onChange: event => setMinUpvoteFilter(event.target.value),
                      placeholder: 'Any'
                    })
                  ),
                  h('p', { className: 'text-xs text-zinc-500' }, 'Raise the floor to focus on higher-signal posts.')
                ),
                h('div', { className: 'rounded-2xl border border-zinc-200 bg-zinc-50 p-3 space-y-2' },
                  h('p', { className: 'text-xs font-semibold uppercase tracking-wide text-zinc-500' }, 'Comment filters'),
                  h('div', { className: 'flex flex-wrap gap-2' },
                    COMMENT_PRESETS.map(value => {
                      const label = value === 'any' ? 'Any' : `${value}+`;
                      const isActive = value === 'any' ? minCommentFilter === '' : minCommentFilter === String(value);
                      return h('button', {
                        key: `comment-${value}`,
                        type: 'button',
                        className: `px-3 py-1.5 rounded-full border text-xs font-semibold transition-colors ${isActive ? 'border-indigo-500 bg-indigo-100 text-indigo-700' : 'border-transparent bg-white text-zinc-600 hover:border-indigo-200'}`,
                        onClick: () => setMinCommentFilter(value === 'any' ? '' : String(value))
                      }, label);
                    })
                  ),
                  h('div', { className: 'flex items-center gap-2' },
                    h('span', { className: 'text-[11px] font-semibold uppercase tracking-wide text-zinc-500' }, 'Custom'),
                    h('input', {
                      type: 'number',
                      inputMode: 'numeric',
                      className: 'flex-1 border rounded-lg px-2 py-1 text-xs',
                      value: minCommentFilter,
                      onChange: event => setMinCommentFilter(event.target.value),
                      placeholder: 'Any'
                    })
                  ),
                  h('p', { className: 'text-xs text-zinc-500' }, 'Find threads with active conversations.')
                ),
                h('div', { className: 'rounded-2xl border border-zinc-200 bg-zinc-50 p-3 space-y-3' },
                  h('p', { className: 'text-xs font-semibold uppercase tracking-wide text-zinc-500' }, 'Sort'),
                  h('label', { className: 'flex flex-col gap-1 text-xs font-medium text-zinc-600' },
                    'Order by',
                    h('select', {
                      className: 'border rounded-lg px-3 py-2 text-xs',
                      value: sortBy,
                      onChange: event => setSortBy(event.target.value)
                    },
                      h('option', { value: 'date' }, 'Date'),
                      h('option', { value: 'upvotes' }, 'Upvotes'),
                      h('option', { value: 'comments' }, 'Comments')
                    )
                  ),
                  h('label', { className: 'flex flex-col gap-1 text-xs font-medium text-zinc-600' },
                    'Order',
                    h('select', {
                      className: 'border rounded-lg px-3 py-2 text-xs',
                      value: sortOrder,
                      onChange: event => setSortOrder(event.target.value)
                    },
                      h('option', { value: 'desc' }, sortBy === 'date' ? 'Newest' : 'High → Low'),
                      h('option', { value: 'asc' }, sortBy === 'date' ? 'Oldest' : 'Low → High')
                    )
                  )
                )
              ),
              h('div', { className: 'flex flex-wrap items-center justify-between text-xs text-zinc-600' },
                h('button', {
                  type: 'button',
                  className: 'font-semibold text-indigo-600 hover:text-indigo-700',
                  onClick: () => setShowAdvancedFilters(prev => !prev)
                }, showAdvancedFilters ? 'Hide advanced filters' : 'More filters'),
                filtersActive && h('button', {
                  type: 'button',
                  className: 'font-semibold text-zinc-500 hover:text-zinc-700',
                  onClick: () => {
                    setMinUpvoteFilter('');
                    setMaxUpvoteFilter('');
                    setMinCommentFilter('');
                    setMaxCommentFilter('');
                  }
                }, 'Clear filters')
              ),
              showAdvancedFilters && h('div', { className: 'grid gap-3 sm:grid-cols-2' },
                h('label', { className: 'flex flex-col gap-1 text-sm font-medium text-zinc-700' },
                  'Max upvotes',
                  h('input', {
                    type: 'number',
                    inputMode: 'numeric',
                    className: 'border rounded-lg px-3 py-2 text-sm',
                    value: maxUpvoteFilter,
                    onChange: event => setMaxUpvoteFilter(event.target.value),
                    placeholder: 'No max'
                  })
                ),
                h('label', { className: 'flex flex-col gap-1 text-sm font-medium text-zinc-700' },
                  'Max comments',
                  h('input', {
                    type: 'number',
                    inputMode: 'numeric',
                    className: 'border rounded-lg px-3 py-2 text-sm',
                    value: maxCommentFilter,
                    onChange: event => setMaxCommentFilter(event.target.value),
                    placeholder: 'No max'
                  })
                )
              )
            ),
            visiblePosts.length === 0 && h('div', { className: 'text-sm text-zinc-500' },
              subs.length === 0
                ? 'Add some subreddits to get started!'
                : 'No posts. Try Refresh or adjust filters.'
            ),
            h('ul', { className: 'space-y-2' },
              visiblePosts.map(post => {
                const rawScore = Number(post.score);
                const rawComments = Number(post.num_comments);
                const scoreValue = Number.isFinite(rawScore) ? Math.max(0, rawScore) : 0;
                const commentValue = Number.isFinite(rawComments) ? Math.max(0, rawComments) : 0;
                const scoreIntensity = scaleCountIntensity(scoreValue, maxScore);
                const commentIntensity = scaleCountIntensity(commentValue, maxComments);
                const scoreStyles = {
                  backgroundColor: tintWithWhite('#22c55e', Math.max(0.25, scoreIntensity * 0.8), { minMix: 0.2, maxMix: 0.8 }),
                  color: '#047857'
                };
                const commentStyles = {
                  backgroundColor: tintWithWhite('#f59e0b', Math.max(0.25, commentIntensity * 0.8), { minMix: 0.2, maxMix: 0.8 }),
                  color: '#92400e'
                };
                const isSelected = selectedPost && selectedPost.id === post.id;

                return h('li', { key: post.id },
                  h('button', {
                    className: `group w-full text-left rounded-xl border transition-colors focus:outline-none focus:ring-2 focus:ring-indigo-300 ${isSelected ? 'border-indigo-400 bg-indigo-50/60 shadow-sm' : 'border-zinc-200 bg-white hover:border-indigo-200'}`,
                    onClick: () => setSelectedPost(post)
                  },
                    h('div', { className: 'flex gap-3 items-start p-3' },
                      h('div', {
                        className: `w-1 rounded-full self-stretch transition-colors ${isSelected ? 'bg-indigo-500' : 'bg-transparent group-hover:bg-indigo-200'}`
                      }),
                      post.thumbnail && h('img', {
                        src: post.thumbnail,
                        alt: '',
                        className: 'w-14 h-14 object-cover rounded-lg'
                      }),
                      h('div', { className: 'flex-1 space-y-2' },
                        h('div', { className: 'flex flex-wrap items-center gap-2 text-xs text-zinc-500' },
                          h('span', { className: 'tracking-wide uppercase' }, timeAgo(post.created_utc)),
                          h('span', { className: 'px-2 py-0.5 rounded bg-zinc-100 text-zinc-700' }, `r/${post.subreddit}`)
                        ),
                        h('div', { className: 'font-semibold leading-snug text-sm text-zinc-900' }, post.title || ''),
                        h('div', { className: 'flex flex-wrap items-center gap-2 text-sm' },
                          h('span', { className: 'inline-flex items-center gap-1 rounded-full px-3 py-1 text-xs font-semibold', style: scoreStyles }, `▲ ${scoreValue} upvotes`),
                          h('span', { className: 'inline-flex items-center gap-1 rounded-full px-3 py-1 text-xs font-semibold', style: commentStyles }, `💬 ${commentValue} comments`),
                          h('span', { className: 'text-zinc-600' }, `u/${post.author} • ${post.domain}`)
                        )
                      )
                    )
                  )
                );
              })
            )
          ),
          h('section', { className: 'lg:col-span-4 bg-white rounded-2xl shadow p-4 max-h-[80vh] overflow-auto space-y-3' },
            h('h2', { className: 'font-semibold' }, 'Post'),
            !selectedPost
              ? h('div', { className: 'text-sm text-zinc-500 border border-dashed border-zinc-200 rounded-xl p-4' }, 'Select a post to preview.')
              : h('article', { className: 'space-y-3' },
                  h('div', { className: 'flex flex-wrap items-center gap-2 text-xs text-zinc-500' },
                    h('span', { className: 'tracking-wide uppercase' }, timeAgo(selectedPost.created_utc)),
                    h('span', { className: 'px-2 py-0.5 rounded bg-zinc-100 text-zinc-700' }, `r/${selectedPost.subreddit}`)
                  ),
                  h('h3', { className: 'text-lg font-bold leading-snug text-zinc-900' }, selectedPost.title || ''),
                  h('div', { className: 'flex flex-wrap gap-2' },
                    h('a', {
                      href: selectedPost.url,
                      target: '_blank',
                      rel: 'noreferrer',
                      className: 'inline-flex items-center justify-center rounded-lg bg-black px-4 py-2 text-sm font-semibold text-white shadow transition-colors hover:bg-zinc-900'
                    }, 'Open on Reddit')
                  ),
                  h('div', { className: 'flex flex-wrap items-center gap-2 text-sm' },
                    h('span', {
                      className: 'inline-flex items-center gap-1 rounded-full px-3 py-1 text-xs font-semibold',
                      style: {
                        backgroundColor: tintWithWhite('#22c55e', Math.max(0.25, scaleCountIntensity(Number(selectedPost.score) || 0, maxScore) * 0.8), { minMix: 0.2, maxMix: 0.8 }),
                        color: '#047857'
                      }
                    }, `▲ ${selectedPost.score} upvotes`),
                    h('span', {
                      className: 'inline-flex items-center gap-1 rounded-full px-3 py-1 text-xs font-semibold',
                      style: {
                        backgroundColor: tintWithWhite('#f59e0b', Math.max(0.25, scaleCountIntensity(Number(selectedPost.num_comments) || 0, maxComments) * 0.8), { minMix: 0.2, maxMix: 0.8 }),
                        color: '#92400e'
                      }
                    }, `💬 ${selectedPost.num_comments} comments`),
                    h('span', { className: 'text-zinc-600' }, `u/${selectedPost.author} • ${selectedPost.domain}`)
                  ),
                  renderBody(selectedPost)
                )
          )
        ),
        starterPackOpen && h('div', { className: 'fixed inset-0 z-50 flex items-center justify-center bg-black/40 p-4' },
          h('div', { className: 'relative w-full max-w-2xl rounded-3xl bg-white p-6 shadow-xl space-y-5' },
            h('button', {
              type: 'button',
              className: 'absolute right-4 top-4 text-sm font-semibold text-zinc-400 hover:text-zinc-600',
              onClick: () => setStarterPackOpen(false)
            }, 'Close'),
            h('div', { className: 'space-y-2' },
              h('h3', { className: 'text-xl font-semibold text-zinc-900' }, 'Starter packs'),
              h('p', { className: 'text-sm text-zinc-600' }, 'Choose a preset to merge into your list. We\'ll keep any communities you\'ve already added.')
            ),
            h('div', { className: 'grid gap-3 sm:grid-cols-2' },
              STARTER_PACKS.map(pack =>
                h('button', {
                  key: pack.id,
                  className: 'text-left rounded-2xl border border-zinc-200 bg-zinc-50 p-4 transition-colors hover:border-indigo-300 hover:bg-indigo-50',
                  onClick: () => {
                    handleApplyStarterPack(pack);
                    setStarterPackOpen(false);
                  }
                },
                  h('div', { className: 'text-sm font-semibold text-zinc-900' }, pack.label),
                  h('p', { className: 'text-xs text-zinc-600 mt-2 leading-relaxed' }, pack.description),
                  h('p', { className: 'mt-3 text-[11px] uppercase tracking-wide text-zinc-400' }, `${pack.subs.length} subreddit${pack.subs.length > 1 ? 's' : ''}`)
                )
              )
            ),
            h('div', { className: 'flex justify-end' },
              h('button', {
                type: 'button',
                className: 'inline-flex items-center justify-center rounded-lg border border-zinc-200 px-4 py-2 text-sm font-semibold text-zinc-700 hover:bg-zinc-50',
                onClick: () => setStarterPackOpen(false)
              }, 'Done')
            )
          )
        )
      );

    }

    function formatTimeUntil(timestamp) {
      if (!timestamp) return '';
      const now = Date.now();
      const diff = Math.max(0, Number(timestamp) - now);
      if (!Number.isFinite(diff) || diff <= 0) return 'in a few seconds';
      if (diff < 60 * 1000) return 'in under a minute';
      const minutes = Math.round(diff / 60000);
      if (minutes < 60) {
        return `in ${minutes} minute${minutes === 1 ? '' : 's'}`;
      }
      const hours = Math.floor(minutes / 60);
      const remainingMinutes = minutes % 60;
      if (hours >= 24) {
        const days = Math.round(diff / 86400000);
        return `in ${days} day${days === 1 ? '' : 's'}`;
      }
      if (remainingMinutes === 0) {
        return `in ${hours} hour${hours === 1 ? '' : 's'}`;
      }
      return `in ${hours}h ${remainingMinutes}m`;
    }

    function uniqueNormalizedSubreddits(input) {
      if (typeof input !== 'string') return [];
      const segments = input.split(/[\n,]+/);
      const seen = new Set();
      const list = [];
      for (const segment of segments) {
        const normalized = normalizeSubredditName(segment);
        if (!normalized) continue;
        const key = normalized.toLowerCase();
        if (seen.has(key)) continue;
        seen.add(key);
        list.push(normalized);
      }
      return list;
    }

    function mergeSubredditLists(existing, additions) {
      const base = Array.isArray(existing) ? existing : [];
      const seen = new Set(base.map(item => (typeof item === 'string' ? item.toLowerCase() : '')));
      const merged = [...base];
      for (const entry of Array.isArray(additions) ? additions : []) {
        const normalized = normalizeSubredditName(entry);
        if (!normalized) continue;
        const key = normalized.toLowerCase();
        if (seen.has(key)) continue;
        seen.add(key);
        merged.push(normalized);
      }
      if (merged.length === base.length) {
        return Array.isArray(existing) ? existing : base;
      }
      return merged;
    }

    function normalizeSubredditName(value) {
      if (typeof value !== 'string') return '';
      const trimmed = value.trim();
      if (!trimmed) return '';
      const withoutPrefix = trimmed.replace(/^r\//i, '').trim();
      return withoutPrefix;
    }

    function formatDateTime(timestamp) {
      const date = new Date(timestamp);
      if (Number.isNaN(date.getTime())) return '';
      return date.toLocaleString(undefined, {
        year: 'numeric',
        month: 'short',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit'
      });
    }

    function timeAgo(utcSeconds) {
      const now = Date.now() / 1000;
      const diff = Math.max(1, Math.floor(now - (utcSeconds || 0)));
      const units = [
        [31536000, 'year'],
        [2592000, 'month'],
        [604800, 'week'],
        [86400, 'day'],
        [3600, 'hour'],
        [60, 'minute'],
        [1, 'second'],
      ];
      for (const [seconds, name] of units) {
        if (diff >= seconds) {
          const count = Math.floor(diff / seconds);
          return `${count} ${name}${count > 1 ? 's' : ''} ago`;
        }
      }
      return 'just now';
    }

    function formatSubs(value) {
      if (!value && value !== 0) return '';
      if (value < 1000) return String(value);
      const units = ['k', 'M', 'B'];
      let unitIndex = -1;
      let val = value;
      while (val >= 1000 && unitIndex < units.length - 1) {
        val /= 1000;
        unitIndex += 1;
      }
      return `${val.toFixed(val >= 10 ? 0 : 1)}${units[unitIndex]}`;
    }

    function parseNumberFilter(value) {
      if (value === null || value === undefined) return null;
      const trimmed = String(value).trim();
      if (trimmed === '') return null;
      const num = Number(trimmed);
      return Number.isFinite(num) ? num : null;
    }

    function renderBody(post) {
      if (post.selftext_html) {
        const decoded = decodeHtml(post.selftext_html);
        return h('div', {
          className: 'post-body prose prose-zinc max-w-none',
          dangerouslySetInnerHTML: { __html: decoded },
        });
      }
      if (post.selftext) {
        return h('div', { className: 'post-body whitespace-pre-wrap text-zinc-800' }, post.selftext);
      }
      return h('div', { className: 'text-sm text-zinc-500' }, '(No text body — link post)');
    }

    function decodeHtml(str) {
      return str
        .replace(/&lt;/g, '<')
        .replace(/&gt;/g, '>')
        .replace(/&amp;/g, '&')
        .replace(/&quot;/g, '"')
        .replace(/&#39;/g, "'");
    }

    function scaleCountIntensity(value, maxValue) {
      const rawValue = Number.isFinite(value) ? value : Number(value);
      const rawMax = Number.isFinite(maxValue) ? maxValue : Number(maxValue);
      const safeValue = Number.isFinite(rawValue) ? Math.max(0, rawValue) : 0;
      const safeMax = Number.isFinite(rawMax) ? Math.max(0, rawMax) : 0;
      if (safeValue <= 0) return 0;
      if (safeMax <= 0) return 1;
      const ratio = Math.log1p(safeValue) / Math.log1p(Math.max(1, safeMax));
      if (!Number.isFinite(ratio) || ratio <= 0) return 0;
      return Math.min(1, Math.max(0, ratio));
    }

    function tintWithWhite(hexColor, intensity, { minMix = 0.2, maxMix = 0.85 } = {}) {
      const { r, g, b } = hexToRgb(hexColor);
      const clampedIntensity = Math.min(1, Math.max(0, intensity || 0));
      const clampedMin = Math.min(1, Math.max(0, minMix));
      const clampedMax = Math.min(1, Math.max(0, maxMix));
      const mix = clampedMax - clampedIntensity * Math.max(0, clampedMax - clampedMin);
      const final = {
        r: Math.round(r + (255 - r) * mix),
        g: Math.round(g + (255 - g) * mix),
        b: Math.round(b + (255 - b) * mix),
      };
      return `rgb(${final.r}, ${final.g}, ${final.b})`;
    }

    function hexToRgb(hexColor) {
      if (typeof hexColor !== 'string') {
        return { r: 255, g: 255, b: 255 };
      }
      let hex = hexColor.replace('#', '').trim();
      if (hex.length === 3) {
        hex = hex.split('').map(char => char + char).join('');
      }
      if (hex.length !== 6) {
        return { r: 255, g: 255, b: 255 };
      }
      const value = parseInt(hex, 16);
      if (Number.isNaN(value)) {
        return { r: 255, g: 255, b: 255 };
      }
      return {
        r: (value >> 16) & 255,
        g: (value >> 8) & 255,
        b: value & 255,
      };
    }

    // Client-side Reddit API fetching removed due to CORS issues

    // Removed unused client-side functions

    const root = createRoot(document.getElementById('root'));
    root.render(h(App));
  </script>
</body>
</html>
