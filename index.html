<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Reddit Three-Pane Dashboard</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
  <script src="https://cdn.tailwindcss.com"></script>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <style>
    body { font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial; }
  </style>
</head>
<body class="bg-zinc-50 min-h-screen text-zinc-900">
  <div id="root"></div>
  <script>
    const { useEffect, useMemo, useState } = React;
    const { createRoot } = ReactDOM;
    const h = React.createElement;

    const DEFAULT_API_URL = "/api/reddit";
    const DEFAULT_SUBS = [];

    function App() {
      const [subs, setSubs] = useState(() => {
        try {
          // Try primary storage first
          let saved = localStorage.getItem('dashboard_subs');
          if (saved) return JSON.parse(saved);
          
          // Fallback to backup storage
          saved = localStorage.getItem('dashboard_subs_backup');
          if (saved) {
            const parsed = JSON.parse(saved);
            // Restore to primary storage
            localStorage.setItem('dashboard_subs', saved);
            return parsed;
          }
        } catch (error) {
          console.warn('Unable to parse saved subs', error);
        }
        return DEFAULT_SUBS;
      });
      const [subsInput, setSubsInput] = useState(() => {
        try {
          const saved = localStorage.getItem('dashboard_subs');
          if (saved) {
            const subs = JSON.parse(saved);
            return subs.join(', ');
          }
        } catch (error) {
          console.warn('Unable to parse saved subs', error);
        }
        return '';
      });
      const [mode, setMode] = useState('new');
      const [time, setTime] = useState('day');
      const [days, setDays] = useState(1);
      const [limit, setLimit] = useState(100);
      const [maxPages, setMaxPages] = useState(() => {
        try {
          const saved = localStorage.getItem('dashboard_max_pages');
          if (saved) return Math.max(1, Math.min(500, Number(saved) || 5));
        } catch (error) {}
        return 100;
      });
      const [loading, setLoading] = useState(false);
      const [error, setError] = useState('');
      const [data, setData] = useState([]);
      const [selectedSub, setSelectedSub] = useState('ALL');
      const [selectedPost, setSelectedPost] = useState(null);
      const [fetchedAt, setFetchedAt] = useState(null);
      const [keyword, setKeyword] = useState('');
      const [fetchMethod, setFetchMethod] = useState('server'); // Track which method was used
      const [apiUrl, setApiUrl] = useState(() => {
        try {
          const saved = localStorage.getItem('dashboard_api_url');
          if (saved) return saved;
        } catch (error) {
          console.warn('Unable to read saved API URL', error);
        }
        return DEFAULT_API_URL;
      });

      useEffect(() => {
        try {
          // Save to both primary and backup storage
          const subsJson = JSON.stringify(subs);
          localStorage.setItem('dashboard_subs', subsJson);
          localStorage.setItem('dashboard_subs_backup', subsJson);
          
          // Also save a timestamp for debugging
          localStorage.setItem('dashboard_subs_last_saved', new Date().toISOString());
        } catch (storageError) {
          console.warn('Unable to persist subs', storageError);
        }
      }, [subs]);

      useEffect(() => {
        // Sync subsInput when subs changes (e.g., from localStorage)
        setSubsInput(subs.join(', '));
      }, [subs]);

      useEffect(() => {
        try {
          localStorage.setItem('dashboard_api_url', apiUrl);
        } catch (storageError) {
          console.warn('Unable to persist API URL', storageError);
        }
      }, [apiUrl]);
      useEffect(() => {
        try { localStorage.setItem('dashboard_max_pages', String(maxPages)); } catch {}
      }, [maxPages]);

      const allPosts = useMemo(() => {
        const rows = [];
        for (const group of data) {
          for (const post of group.posts || []) {
            rows.push(post);
          }
        }
        rows.sort((a, b) => (b.created_utc || 0) - (a.created_utc || 0));
        return rows;
      }, [data]);

      const filteredBySub = useMemo(() => {
        if (selectedSub === 'ALL') return allPosts;
        const selected = selectedSub.toLowerCase();
        return allPosts.filter(post => post.subreddit?.toLowerCase() === selected);
      }, [allPosts, selectedSub]);

      const visiblePosts = useMemo(() => {
        const q = keyword.trim().toLowerCase();
        if (!q) return filteredBySub;
        return filteredBySub.filter(post => {
          const title = post.title ? post.title.toLowerCase() : '';
          const selftext = post.selftext ? post.selftext.toLowerCase() : '';
          return title.includes(q) || selftext.includes(q);
        });
      }, [filteredBySub, keyword]);

      const subMetaMap = useMemo(() => {
        const map = new Map();
        for (const group of data) {
          map.set(group.subreddit, group.meta || null);
        }
        return map;
      }, [data]);
      const subPartialMap = useMemo(() => {
        const map = new Map();
        for (const group of data) {
          map.set(group.subreddit, Boolean(group.partial));
        }
        return map;
      }, [data]);

      async function refresh() {
        if (!subs.length) {
          setError('Please add at least one subreddit.');
          setData([]);
          setFetchedAt(null);
          return;
        }

        setLoading(true);
        setError('');
        setSelectedPost(null);
        try {
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 15000);
          const params = new URLSearchParams({
            subs: subs.join(','),
            mode,
            time,
            days: String(days),
            limit: String(limit)
          });
          if (mode === 'new') {
            params.set('max_pages', String(maxPages));
          }

          // Try client-side Reddit API first, fallback to server API
          let response;
          let usedClientSide = false;
          try {
            // Client-side approach - make requests directly from browser
            response = await fetchFromRedditClientSide(subs, mode, time, days, limit, maxPages, controller);
            usedClientSide = true;
            setFetchMethod('client');
            console.log('Successfully used client-side fetching');
          } catch (clientError) {
            console.warn('Client-side fetch failed, trying server API:', clientError.message);
            setFetchMethod('server');
            // Fallback to server API
            const qs = new URLSearchParams(params);
            response = await fetch(`${apiUrl}?${qs.toString()}`, { cache: 'no-store', signal: controller.signal });
          }
          if (!response.ok) throw new Error(`HTTP ${response.status}`);
          const payload = await response.json();
          clearTimeout(timeoutId);
          const results = Array.isArray(payload.results) ? payload.results : [];
          const perSub = subs.map(sub => {
            const match = results.find(r => (r.subreddit || '').toLowerCase() === sub.toLowerCase());
            if (match) return {
              subreddit: match.subreddit,
              meta: match.meta || null,
              posts: match.posts || [],
              partial: Boolean(match.partial),
              error: match.error || null,
            };
            return { subreddit: sub, posts: [], meta: null, partial: false, error: null };
          });
          setData(perSub);
          setFetchedAt(Date.now());
        } catch (fetchError) {
          if (fetchError && fetchError.name === 'AbortError') {
            setError('Request timed out (15s). Reddit may be rate limiting. Try fewer subreddits or try again.');
          } else if (fetchError && typeof fetchError.message === 'string' && fetchError.message.toLowerCase().includes('rate')) {
            setError('Reddit is rate limiting right now. Please wait a minute and try again.');
          } else {
            setError(fetchError.message || 'Failed to fetch');
          }
          setData([]);
          setFetchedAt(null);
        } finally {
          setLoading(false);
        }
      }

      // Auto-refresh disabled by request: no background interval, no initial fetch
      // useEffect(() => {
      //   const id = setInterval(() => {
      //     refresh();
      //   }, 60 * 60 * 1000);
      //   return () => clearInterval(id);
      //   // eslint-disable-next-line react-hooks/exhaustive-deps
      // }, [subs, mode, time, days, limit, maxPages, workerUrl]);

      // useEffect(() => {
      //   refresh();
      //   // eslint-disable-next-line react-hooks/exhaustive-deps
      // }, []);

      return h('div', { className: 'max-w-7xl mx-auto p-4' },
        h('header', { className: 'flex flex-col md:flex-row md:items-end md:justify-between gap-3 mb-4' },
          h('div', null,
            h('h1', { className: 'text-2xl font-extrabold' }, 'Reddit Dashboard'),
            h('p', { className: 'text-zinc-600 text-sm' }, 'Three-pane â€¢ Keyword filter â€¢ Day / 3 Days / Week â€¢ Full post body + subreddit stats')
          ),
          h('div', { className: 'flex flex-wrap items-center gap-2' },
            h('select', {
              className: 'border rounded-lg px-3 py-2',
              value: mode,
              onChange: event => setMode(event.target.value)
            },
              h('option', { value: 'new' }, 'new'),
              h('option', { value: 'top' }, 'top')
            ),
            h('select', {
              className: 'border rounded-lg px-3 py-2',
              value: time,
              onChange: event => setTime(event.target.value),
              disabled: mode !== 'top'
            },
              h('option', { value: 'hour' }, 'hour'),
              h('option', { value: 'day' }, 'day'),
              h('option', { value: 'week' }, 'week'),
              h('option', { value: 'month' }, 'month')
            ),
            h('select', {
              className: 'border rounded-lg px-3 py-2',
              value: days,
              onChange: event => setDays(Number(event.target.value) || 1)
            },
              h('option', { value: 1 }, 'Day'),
              h('option', { value: 3 }, '3 Days'),
              h('option', { value: 7 }, 'Week')
            ),
            h('select', {
              className: 'border rounded-lg px-3 py-2',
              value: maxPages,
              onChange: event => setMaxPages(Math.max(1, Math.min(500, Number(event.target.value) || 100)))
            },
              h('option', { value: 5 }, 'Max pages: 5'),
              h('option', { value: 10 }, 'Max pages: 10'),
              h('option', { value: 20 }, 'Max pages: 20'),
              h('option', { value: 50 }, 'Max pages: 50'),
              h('option', { value: 100 }, 'Max pages: 100'),
              h('option', { value: 200 }, 'Max pages: 200')
            ),
            h('button', {
              onClick: refresh,
              className: 'px-4 py-2 rounded-xl bg-black text-white font-semibold shadow disabled:opacity-50',
              disabled: loading
            }, loading ? 'Fetchingâ€¦' : 'Refresh')
          )
        ),
        h('div', { className: 'bg-white rounded-2xl shadow p-3 mb-3' },
          h('div', { className: 'flex flex-col md:flex-row gap-2 md:items-center' },
            h('label', { className: 'text-sm text-zinc-600 md:w-28' }, 'API URL'),
            h('input', {
              className: 'flex-1 border rounded-lg px-3 py-2',
              value: apiUrl,
              onChange: event => setApiUrl(event.target.value)
            })
          ),
          h('div', { className: 'flex flex-col md:flex-row gap-2 md:items-center mt-2' },
            h('label', { className: 'text-sm text-zinc-600 md:w-28' }, 'Subreddits'),
            h('textarea', {
              className: 'flex-1 border rounded-lg px-3 py-2',
              rows: 2,
              value: subsInput,
              placeholder: 'Enter subreddit names separated by commas (e.g., programming, technology, webdev)',
              onChange: event => setSubsInput(event.target.value),
              onBlur: event => {
                const list = event.target.value.split(',').map(item => item.trim()).filter(Boolean);
                setSubs(list);
                // Immediate backup save to localStorage
                try {
                  localStorage.setItem('dashboard_subs', JSON.stringify(list));
                  localStorage.setItem('dashboard_subs_backup', JSON.stringify(list));
                } catch (e) {
                  console.warn('Failed to save subreddits:', e);
                }
              }
            })
          ),
          h('div', { className: 'flex flex-col md:flex-row gap-2 md:items-center mt-2' },
            h('label', { className: 'text-sm text-zinc-600 md:w-28' }, 'Keyword'),
            h('input', {
              className: 'flex-1 border rounded-lg px-3 py-2',
              value: keyword,
              onChange: event => setKeyword(event.target.value),
              placeholder: 'Type a keyword or phrase'
            })
          ),
          h('div', { className: 'flex flex-wrap gap-2 mt-3 pt-3 border-t border-zinc-200' },
            h('button', {
              className: 'px-3 py-1 text-xs rounded-lg bg-blue-100 text-blue-700 hover:bg-blue-200',
              onClick: () => {
                const backup = JSON.stringify({ subs, apiUrl, maxPages });
                navigator.clipboard.writeText(backup);
                alert('Settings copied to clipboard!');
              }
            }, 'ðŸ“‹ Export Settings'),
            h('button', {
              className: 'px-3 py-1 text-xs rounded-lg bg-green-100 text-green-700 hover:bg-green-200',
              onClick: () => {
                const input = prompt('Paste your settings backup:');
                if (input) {
                  try {
                    const parsed = JSON.parse(input);
                    if (parsed.subs) setSubs(parsed.subs);
                    if (parsed.apiUrl) setApiUrl(parsed.apiUrl);
                    if (parsed.workerUrl) setApiUrl(parsed.workerUrl); // backward compatibility
                    if (parsed.maxPages) setMaxPages(parsed.maxPages);
                    alert('Settings restored!');
                  } catch (e) {
                    alert('Invalid backup format');
                  }
                }
              }
            }, 'ðŸ“¥ Import Settings'),
            h('span', { className: 'text-xs text-zinc-500 self-center' },
              `Saved: ${localStorage.getItem('dashboard_subs_last_saved')?.slice(11, 19) || 'Never'}`
            )
          )
        ),
        h('div', { className: 'text-sm text-zinc-600 mb-2' },
          error
            ? h('span', { className: 'text-red-600' }, `Error: ${error}`)
            : h('span', null, 
                loading 
                  ? 'â³ Fetching from Reddit (this may take 30-60 seconds due to rate limits)...'
                  : `Fetched: ${fetchedAt ? formatDateTime(fetchedAt) : 'â€”'} â€¢ Posts: ${visiblePosts.length} â€¢ Mode: ${mode}${mode === 'top' ? ` (t=${time})` : ''} â€¢ Range: ${days} day(s) â€¢ Method: ${fetchMethod === 'client' ? 'ðŸŒ Client-side' : 'ðŸ–¥ï¸ Server'}`
              )
        ),
        h('div', { className: 'grid grid-cols-1 lg:grid-cols-12 gap-4' },
          h('aside', { className: 'lg:col-span-3 bg-white rounded-2xl shadow p-3' },
            h('div', { className: 'flex items-center justify-between mb-2' },
              h('h2', { className: 'font-semibold' }, 'Subreddits'),
              h('button', {
                className: 'text-xs px-2 py-1 rounded-lg bg-zinc-100',
                onClick: () => setSelectedSub('ALL')
              }, 'All')
            ),
            subs.length === 0 
              ? h('div', { className: 'text-sm text-zinc-500 italic' }, 'No subreddits added yet')
              : h('ul', { className: 'space-y-1 max-h-[70vh] overflow-auto' },
                  subs.map(sub => {
                    const meta = subMetaMap.get(sub) || {};
                    const capped = subPartialMap.get(sub);
                    return h('li', { key: sub },
                      h('button', {
                        onClick: () => setSelectedSub(sub),
                        className: `w-full text-left px-2 py-2 rounded-lg hover:bg-zinc-100 ${selectedSub === sub ? 'bg-zinc-100 font-semibold' : 'text-zinc-800'}`
                      },
                        h('div', { className: 'flex items-center justify-between' },
                          h('span', null, `r/${sub}`),
                          h('span', { className: 'flex items-center gap-2 text-xs text-zinc-500' },
                            capped ? h('span', { className: 'px-1.5 py-0.5 rounded bg-orange-100 text-orange-700 border border-orange-200' }, 'capped') : null,
                            `${formatSubs(meta.subscribers)} subs${meta.active_user_count ? ` â€¢ ${formatSubs(meta.active_user_count)} active` : ''}`
                          )
                        )
                      )
                    );
                  })
                ),
            h('p', { className: 'text-[11px] text-zinc-500 mt-2' }, 'Active â‰ˆ users online/active (15m window if provided by Reddit). Weekly contributors arenâ€™t available via public endpoints.')
          ),
          h('main', { className: 'lg:col-span-5 bg-white rounded-2xl shadow p-3 max-h-[80vh] overflow-auto' },
            h('h2', { className: 'font-semibold mb-2' }, selectedSub === 'ALL' ? 'Latest from all' : `Latest in r/${selectedSub}`),
            visiblePosts.length === 0 && h('div', { className: 'text-sm text-zinc-500' }, 
              subs.length === 0 
                ? 'Add some subreddits above to get started!'
                : 'No posts. Try Refresh or adjust filters.'
            ),
            h('ul', { className: 'divide-y' },
              visiblePosts.map(post => h('li', { key: post.id },
                h('button', {
                  className: 'w-full text-left py-3 hover:bg-zinc-50',
                  onClick: () => setSelectedPost(post)
                },
                  h('div', { className: 'flex gap-3 items-start px-2' },
                    post.thumbnail && h('img', {
                      src: post.thumbnail,
                      alt: '',
                      className: 'w-14 h-14 object-cover rounded-lg'
                    }),
                    h('div', { className: 'flex-1' },
                      h('div', { className: 'flex items-center gap-2 text-xs text-zinc-500' },
                        h('span', { className: 'tracking-wide uppercase' }, timeAgo(post.created_utc)),
                        h('span', { className: 'px-2 py-0.5 rounded bg-zinc-100 text-zinc-700' }, `r/${post.subreddit}`)
                      ),
                      h('div', { className: 'font-semibold leading-snug mt-1' }, post.title || ''),
                      h('div', { className: 'flex flex-wrap items-center gap-2 mt-1 text-sm' },
                        h('span', { className: 'px-2 py-0.5 rounded bg-green-100 text-green-700 font-semibold' }, `â–² ${post.score} upvotes`),
                        h('span', { className: 'px-2 py-0.5 rounded bg-yellow-100 text-yellow-700 font-semibold' }, `ðŸ’¬ ${post.num_comments} comments`),
                        h('span', { className: 'text-zinc-600' }, `u/${post.author} â€¢ ${post.domain}`)
                      )
                    )
                  )
                ))
              )
            )
          ),
          h('section', { className: 'lg:col-span-4 bg-white rounded-2xl shadow p-3 max-h-[80vh] overflow-auto' },
            h('h2', { className: 'font-semibold mb-2' }, 'Post'),
            !selectedPost
              ? h('div', { className: 'text-sm text-zinc-500' }, 'Select a post to preview.')
              : h('article', null,
                  h('div', { className: 'flex items-center gap-2 text-xs text-zinc-500' },
                    h('span', { className: 'tracking-wide uppercase' }, timeAgo(selectedPost.created_utc)),
                    h('span', { className: 'px-2 py-0.5 rounded bg-zinc-100 text-zinc-700' }, `r/${selectedPost.subreddit}`)
                  ),
                  h('h3', { className: 'text-lg font-bold mt-1 mb-2' }, selectedPost.title || ''),
                  h('div', { className: 'flex flex-wrap items-center gap-2 text-sm mb-3' },
                    h('span', { className: 'px-2 py-0.5 rounded bg-green-100 text-green-700 font-semibold' }, `â–² ${selectedPost.score} upvotes`),
                    h('span', { className: 'px-2 py-0.5 rounded bg-yellow-100 text-yellow-700 font-semibold' }, 'ðŸ’¬ ' + String(selectedPost.num_comments) + ' comments'),
                    h('span', { className: 'text-zinc-600' }, `u/${selectedPost.author} â€¢ ${selectedPost.domain}`)
                  ),
                  renderBody(selectedPost),
                  h('a', {
                    href: selectedPost.url,
                    target: '_blank',
                    rel: 'noreferrer',
                    className: 'inline-block mt-4 px-4 py-2 rounded-xl bg-black text-white font-semibold shadow'
                  }, 'Open on Reddit')
                )
          )
        )
      );

    }

    function formatDateTime(timestamp) {
      const date = new Date(timestamp);
      if (Number.isNaN(date.getTime())) return '';
      return date.toLocaleString(undefined, {
        year: 'numeric',
        month: 'short',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit'
      });
    }

    function timeAgo(utcSeconds) {
      const now = Date.now() / 1000;
      const diff = Math.max(1, Math.floor(now - (utcSeconds || 0)));
      const units = [
        [31536000, 'year'],
        [2592000, 'month'],
        [604800, 'week'],
        [86400, 'day'],
        [3600, 'hour'],
        [60, 'minute'],
        [1, 'second'],
      ];
      for (const [seconds, name] of units) {
        if (diff >= seconds) {
          const count = Math.floor(diff / seconds);
          return `${count} ${name}${count > 1 ? 's' : ''} ago`;
        }
      }
      return 'just now';
    }

    function formatSubs(value) {
      if (!value && value !== 0) return '';
      if (value < 1000) return String(value);
      const units = ['k', 'M', 'B'];
      let unitIndex = -1;
      let val = value;
      while (val >= 1000 && unitIndex < units.length - 1) {
        val /= 1000;
        unitIndex += 1;
      }
      return `${val.toFixed(val >= 10 ? 0 : 1)}${units[unitIndex]}`;
    }

    function renderBody(post) {
      if (post.selftext_html) {
        const decoded = decodeHtml(post.selftext_html);
        return h('div', {
          className: 'prose prose-zinc max-w-none',
          dangerouslySetInnerHTML: { __html: decoded },
        });
      }
      if (post.selftext) {
        return h('div', { className: 'whitespace-pre-wrap text-[15px] leading-6 text-zinc-800' }, post.selftext);
      }
      return h('div', { className: 'text-sm text-zinc-500' }, '(No text body â€” link post)');
    }

    function decodeHtml(str) {
      return str
        .replace(/&lt;/g, '<')
        .replace(/&gt;/g, '>')
        .replace(/&amp;/g, '&')
        .replace(/&quot;/g, '"')
        .replace(/&#39;/g, "'");
    }

    // Client-side Reddit API fetching (bypasses server-side blocking)
    async function fetchFromRedditClientSide(subs, mode, time, days, limit, maxPages, controller) {
      console.log('Attempting client-side Reddit fetch for:', subs);
      
      const results = [];
      const cutoff = Math.floor(Date.now() / 1000) - days * 86400;
      
      for (const sub of subs) {
        try {
          // Fetch subreddit metadata
          const aboutUrl = `https://www.reddit.com/r/${encodeURIComponent(sub)}/about.json`;
          const aboutResponse = await fetch(aboutUrl, { 
            signal: controller.signal,
            headers: {
              'Accept': 'application/json',
              'Cache-Control': 'no-cache'
            }
          });
          
          let meta = null;
          if (aboutResponse.ok) {
            const aboutData = await aboutResponse.json();
            meta = aboutData?.data ? {
              subscribers: aboutData.data.subscribers || null,
              active_user_count: aboutData.data.active_user_count || aboutData.data.accounts_active || null,
              title: aboutData.data.title || null,
              icon_img: aboutData.data.icon_img || null,
              description: aboutData.data.public_description || aboutData.data.description || '',
            } : null;
          }

          let posts = [];
          
          if (mode === 'top') {
            const topUrl = `https://www.reddit.com/r/${encodeURIComponent(sub)}/top.json?t=${encodeURIComponent(time)}&limit=${limit}&raw_json=1`;
            const topResponse = await fetch(topUrl, { 
              signal: controller.signal,
              headers: {
                'Accept': 'application/json',
                'Cache-Control': 'no-cache'
              }
            });
            
            if (topResponse.ok) {
              const topData = await topResponse.json();
              posts = normalizeRedditData(topData);
            }
          } else {
            // Fetch new posts with pagination
            let after = '';
            let page = 0;
            const collected = [];
            
            while (page < Math.min(maxPages, 3)) { // Limit to 3 pages for client-side
              const newUrl = `https://www.reddit.com/r/${encodeURIComponent(sub)}/new.json?limit=${limit}${after ? `&after=${after}` : ''}&raw_json=1`;
              const newResponse = await fetch(newUrl, { 
                signal: controller.signal,
                headers: {
                  'Accept': 'application/json',
                  'Cache-Control': 'no-cache'
                }
              });
              
              if (!newResponse.ok) break;
              
              const newData = await newResponse.json();
              const pagePosts = normalizeRedditData(newData);
              if (!pagePosts.length) break;
              
              for (const post of pagePosts) {
                if ((post.created_utc || 0) >= cutoff) {
                  collected.push(post);
                }
              }
              
              after = newData?.data?.after || '';
              page += 1;
              
              if (!after) break;
              
              // Small delay between pages
              await new Promise(resolve => setTimeout(resolve, 500));
            }
            
            posts = collected;
          }
          
          results.push({
            subreddit: sub,
            meta,
            posts,
            partial: false,
            error: null
          });
          
          // Delay between subreddits
          if (subs.indexOf(sub) < subs.length - 1) {
            await new Promise(resolve => setTimeout(resolve, 1000));
          }
          
        } catch (error) {
          console.error(`Client-side fetch failed for r/${sub}:`, error);
          results.push({
            subreddit: sub,
            meta: null,
            posts: [],
            partial: false,
            error: error.message
          });
        }
      }
      
      // Return in the same format as server API
      return {
        ok: true,
        json: async () => ({
          mode,
          time,
          days,
          limit,
          max_pages: maxPages,
          results,
          fetched_at: Date.now(),
        })
      };
    }

    function normalizeRedditData(data) {
      const children = data?.data?.children || [];
      return children.map(child => {
        const post = child.data || {};
        return {
          id: post.id,
          subreddit: post.subreddit,
          title: post.title,
          selftext: post.selftext || '',
          selftext_html: post.selftext_html || '',
          author: post.author,
          url: `https://www.reddit.com${post.permalink}`,
          domain: post.domain,
          score: post.score,
          num_comments: post.num_comments,
          created_utc: post.created_utc,
          thumbnail: validThumbnail(post.thumbnail) ? post.thumbnail : null,
        };
      });
    }

    function validThumbnail(thumbnail) {
      if (!thumbnail) return false;
      return !['self', 'default', 'nsfw', 'image', 'spoiler'].includes(thumbnail);
    }

    const root = createRoot(document.getElementById('root'));
    root.render(h(App));
  </script>
</body>
</html>